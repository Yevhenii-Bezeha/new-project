{"ast":null,"code":"import _asyncToGenerator from \"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// pkg/dist-src/types.js\nvar Algorithm = /* @__PURE__ */(Algorithm2 => {\n  Algorithm2[\"SHA1\"] = \"sha1\";\n  Algorithm2[\"SHA256\"] = \"sha256\";\n  return Algorithm2;\n})(Algorithm || {});\n\n// pkg/dist-src/utils.js\nvar getAlgorithm = signature => {\n  return signature.startsWith(\"sha256=\") ? \"sha256\" : \"sha1\";\n};\n\n// pkg/dist-src/web.js\nvar enc = new TextEncoder();\nfunction hexToUInt8Array(string) {\n  const pairs = string.match(/[\\dA-F]{2}/gi);\n  const integers = pairs.map(function (s) {\n    return parseInt(s, 16);\n  });\n  return new Uint8Array(integers);\n}\nfunction UInt8ArrayToHex(signature) {\n  return Array.prototype.map.call(new Uint8Array(signature), x => x.toString(16).padStart(2, \"0\")).join(\"\");\n}\nfunction getHMACHashName(algorithm) {\n  return {\n    [Algorithm.SHA1]: \"SHA-1\",\n    [Algorithm.SHA256]: \"SHA-256\"\n  }[algorithm];\n}\nfunction importKey(_x, _x2) {\n  return _importKey.apply(this, arguments);\n}\nfunction _importKey() {\n  _importKey = _asyncToGenerator(function* (secret, algorithm) {\n    return crypto.subtle.importKey(\"raw\",\n    // raw format of the key - should be Uint8Array\n    enc.encode(secret), {\n      // algorithm details\n      name: \"HMAC\",\n      hash: {\n        name: getHMACHashName(algorithm)\n      }\n    }, false,\n    // export = false\n    [\"sign\", \"verify\"]\n    // what this key can do\n    );\n  });\n  return _importKey.apply(this, arguments);\n}\nfunction sign(_x3, _x4) {\n  return _sign.apply(this, arguments);\n}\nfunction _sign() {\n  _sign = _asyncToGenerator(function* (options, payload) {\n    const {\n      secret,\n      algorithm\n    } = typeof options === \"object\" ? {\n      secret: options.secret,\n      algorithm: options.algorithm || Algorithm.SHA256\n    } : {\n      secret: options,\n      algorithm: Algorithm.SHA256\n    };\n    if (!secret || !payload) {\n      throw new TypeError(\"[@octokit/webhooks-methods] secret & payload required for sign()\");\n    }\n    if (!Object.values(Algorithm).includes(algorithm)) {\n      throw new TypeError(`[@octokit/webhooks] Algorithm ${algorithm} is not supported. Must be  'sha1' or 'sha256'`);\n    }\n    const signature = yield crypto.subtle.sign(\"HMAC\", yield importKey(secret, algorithm), enc.encode(payload));\n    return `${algorithm}=${UInt8ArrayToHex(signature)}`;\n  });\n  return _sign.apply(this, arguments);\n}\nfunction verify(_x5, _x6, _x7) {\n  return _verify.apply(this, arguments);\n}\nfunction _verify() {\n  _verify = _asyncToGenerator(function* (secret, eventPayload, signature) {\n    if (!secret || !eventPayload || !signature) {\n      throw new TypeError(\"[@octokit/webhooks-methods] secret, eventPayload & signature required\");\n    }\n    const algorithm = getAlgorithm(signature);\n    return yield crypto.subtle.verify(\"HMAC\", yield importKey(secret, algorithm), hexToUInt8Array(signature.replace(`${algorithm}=`, \"\")), enc.encode(eventPayload));\n  });\n  return _verify.apply(this, arguments);\n}\nexport { sign, verify };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}