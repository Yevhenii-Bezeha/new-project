{"ast":null,"code":"\"use strict\";\n\n/**\n * @module LRUCache\n */\nvar _asyncToGenerator = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classPrivateMethodInitSpec = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classStaticPrivateFieldSpecGet = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classStaticPrivateFieldSpecGet.js\").default;\nvar _classStaticPrivateFieldSpecSet = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classStaticPrivateFieldSpecSet.js\").default;\nvar _defineProperty = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nlet _Symbol$iterator;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = typeof process === 'object' && !!process ? process : {};\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n  typeof PROCESS.emitWarning === 'function' ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    constructor() {\n      _defineProperty(this, \"onabort\", void 0);\n      _defineProperty(this, \"_onabort\", []);\n      _defineProperty(this, \"reason\", void 0);\n      _defineProperty(this, \"aborted\", false);\n    }\n    addEventListener(_, fn) {\n      this._onabort.push(fn);\n    }\n  };\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      _defineProperty(this, \"signal\", new AS());\n      warnACPolyfill();\n    }\n    abort(reason) {\n      if (this.signal.aborted) return;\n      //@ts-ignore\n      this.signal.reason = reason;\n      //@ts-ignore\n      this.signal.aborted = true;\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason);\n      }\n      this.signal.onabort?.(reason);\n    }\n  };\n  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return;\n    printACPolyfillWarning = false;\n    emitWarning('AbortController is not defined. If using lru-cache in ' + 'node 14, load an AbortController polyfill from the ' + '`node-abort-controller` package. A minimal polyfill is ' + 'provided for use by LRUCache.fetch(), but it should not be ' + 'relied upon in other contexts (eg, passing it to other APIs that ' + 'use AbortController/AbortSignal might have undesirable effects). ' + 'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n  };\n}\n/* c8 ignore stop */\nconst shouldWarn = code => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n}\nclass Stack {\n  static create(max) {\n    const HeapCls = getUintArray(max);\n    if (!HeapCls) return [];\n    _classStaticPrivateFieldSpecSet(Stack, Stack, _constructing, true);\n    const s = new Stack(max, HeapCls);\n    _classStaticPrivateFieldSpecSet(Stack, Stack, _constructing, false);\n    return s;\n  }\n  constructor(max, HeapCls) {\n    _defineProperty(this, \"heap\", void 0);\n    _defineProperty(this, \"length\", void 0);\n    /* c8 ignore start */\n    if (!_classStaticPrivateFieldSpecGet(Stack, Stack, _constructing)) {\n      throw new TypeError('instantiate Stack using Stack.create(n)');\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max);\n    this.length = 0;\n  }\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\n// private constructor\nvar _constructing = {\n  writable: true,\n  value: false\n};\nvar _max = /*#__PURE__*/new WeakMap();\nvar _maxSize = /*#__PURE__*/new WeakMap();\nvar _dispose = /*#__PURE__*/new WeakMap();\nvar _disposeAfter = /*#__PURE__*/new WeakMap();\nvar _fetchMethod = /*#__PURE__*/new WeakMap();\nvar _size = /*#__PURE__*/new WeakMap();\nvar _calculatedSize = /*#__PURE__*/new WeakMap();\nvar _keyMap = /*#__PURE__*/new WeakMap();\nvar _keyList = /*#__PURE__*/new WeakMap();\nvar _valList = /*#__PURE__*/new WeakMap();\nvar _next = /*#__PURE__*/new WeakMap();\nvar _prev = /*#__PURE__*/new WeakMap();\nvar _head = /*#__PURE__*/new WeakMap();\nvar _tail = /*#__PURE__*/new WeakMap();\nvar _free = /*#__PURE__*/new WeakMap();\nvar _disposed = /*#__PURE__*/new WeakMap();\nvar _sizes = /*#__PURE__*/new WeakMap();\nvar _starts = /*#__PURE__*/new WeakMap();\nvar _ttls = /*#__PURE__*/new WeakMap();\nvar _hasDispose = /*#__PURE__*/new WeakMap();\nvar _hasFetchMethod = /*#__PURE__*/new WeakMap();\nvar _hasDisposeAfter = /*#__PURE__*/new WeakMap();\nvar _initializeTTLTracking = /*#__PURE__*/new WeakSet();\nvar _updateItemAge = /*#__PURE__*/new WeakMap();\nvar _statusTTL = /*#__PURE__*/new WeakMap();\nvar _setItemTTL = /*#__PURE__*/new WeakMap();\nvar _isStale = /*#__PURE__*/new WeakMap();\nvar _initializeSizeTracking = /*#__PURE__*/new WeakSet();\nvar _removeItemSize = /*#__PURE__*/new WeakMap();\nvar _addItemSize = /*#__PURE__*/new WeakMap();\nvar _requireSize = /*#__PURE__*/new WeakMap();\nvar _indexes = /*#__PURE__*/new WeakSet();\nvar _rindexes = /*#__PURE__*/new WeakSet();\nvar _isValidIndex = /*#__PURE__*/new WeakSet();\nvar _evict = /*#__PURE__*/new WeakSet();\nvar _backgroundFetch = /*#__PURE__*/new WeakSet();\nvar _isBackgroundFetch = /*#__PURE__*/new WeakSet();\nvar _connect = /*#__PURE__*/new WeakSet();\nvar _moveToTail = /*#__PURE__*/new WeakSet();\n_Symbol$iterator = Symbol.iterator;\nclass LRUCache {\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals(c) {\n    return {\n      // properties\n      starts: _classPrivateFieldGet(c, _starts),\n      ttls: _classPrivateFieldGet(c, _ttls),\n      sizes: _classPrivateFieldGet(c, _sizes),\n      keyMap: _classPrivateFieldGet(c, _keyMap),\n      keyList: _classPrivateFieldGet(c, _keyList),\n      valList: _classPrivateFieldGet(c, _valList),\n      next: _classPrivateFieldGet(c, _next),\n      prev: _classPrivateFieldGet(c, _prev),\n      get head() {\n        return _classPrivateFieldGet(c, _head);\n      },\n      get tail() {\n        return _classPrivateFieldGet(c, _tail);\n      },\n      free: _classPrivateFieldGet(c, _free),\n      // methods\n      isBackgroundFetch: p => _classPrivateMethodGet(c, _isBackgroundFetch, _isBackgroundFetch2).call(c, p),\n      backgroundFetch: (k, index, options, context) => _classPrivateMethodGet(c, _backgroundFetch, _backgroundFetch2).call(c, k, index, options, context),\n      moveToTail: index => _classPrivateMethodGet(c, _moveToTail, _moveToTail2).call(c, index),\n      indexes: options => _classPrivateMethodGet(c, _indexes, _indexes2).call(c, options),\n      rindexes: options => _classPrivateMethodGet(c, _rindexes, _rindexes2).call(c, options),\n      isStale: index => _classPrivateFieldGet(c, _isStale).call(c, index)\n    };\n  }\n  // Protected read-only members\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max() {\n    return _classPrivateFieldGet(this, _max);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize() {\n    return _classPrivateFieldGet(this, _maxSize);\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize() {\n    return _classPrivateFieldGet(this, _calculatedSize);\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size() {\n    return _classPrivateFieldGet(this, _size);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod() {\n    return _classPrivateFieldGet(this, _fetchMethod);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return _classPrivateFieldGet(this, _dispose);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return _classPrivateFieldGet(this, _disposeAfter);\n  }\n  constructor(_options) {\n    _classPrivateMethodInitSpec(this, _moveToTail);\n    _classPrivateMethodInitSpec(this, _connect);\n    _classPrivateMethodInitSpec(this, _isBackgroundFetch);\n    _classPrivateMethodInitSpec(this, _backgroundFetch);\n    _classPrivateMethodInitSpec(this, _evict);\n    _classPrivateMethodInitSpec(this, _isValidIndex);\n    _classPrivateMethodInitSpec(this, _rindexes);\n    _classPrivateMethodInitSpec(this, _indexes);\n    _classPrivateMethodInitSpec(this, _initializeSizeTracking);\n    _classPrivateMethodInitSpec(this, _initializeTTLTracking);\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    _classPrivateFieldInitSpec(this, _max, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _maxSize, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _dispose, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _disposeAfter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fetchMethod, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    _defineProperty(this, \"ttl\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    _defineProperty(this, \"ttlResolution\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    _defineProperty(this, \"ttlAutopurge\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    _defineProperty(this, \"updateAgeOnGet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    _defineProperty(this, \"updateAgeOnHas\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    _defineProperty(this, \"allowStale\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    _defineProperty(this, \"noDisposeOnSet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    _defineProperty(this, \"noUpdateTTL\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    _defineProperty(this, \"maxEntrySize\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    _defineProperty(this, \"sizeCalculation\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    _defineProperty(this, \"noDeleteOnFetchRejection\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    _defineProperty(this, \"noDeleteOnStaleGet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    _defineProperty(this, \"allowStaleOnFetchAbort\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    _defineProperty(this, \"allowStaleOnFetchRejection\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    _defineProperty(this, \"ignoreFetchAbort\", void 0);\n    // computed properties\n    _classPrivateFieldInitSpec(this, _size, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _calculatedSize, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _keyMap, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _keyList, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _valList, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _next, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _prev, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _head, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _tail, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _free, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _disposed, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _sizes, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _starts, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _ttls, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasDispose, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasFetchMethod, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasDisposeAfter, {\n      writable: true,\n      value: void 0\n    });\n    // conditionally set private methods related to TTL\n    _classPrivateFieldInitSpec(this, _updateItemAge, {\n      writable: true,\n      value: () => {}\n    });\n    _classPrivateFieldInitSpec(this, _statusTTL, {\n      writable: true,\n      value: () => {}\n    });\n    _classPrivateFieldInitSpec(this, _setItemTTL, {\n      writable: true,\n      value: () => {}\n    });\n    /* c8 ignore stop */\n    _classPrivateFieldInitSpec(this, _isStale, {\n      writable: true,\n      value: () => false\n    });\n    _classPrivateFieldInitSpec(this, _removeItemSize, {\n      writable: true,\n      value: _i => {}\n    });\n    _classPrivateFieldInitSpec(this, _addItemSize, {\n      writable: true,\n      value: (_i, _s, _st) => {}\n    });\n    _classPrivateFieldInitSpec(this, _requireSize, {\n      writable: true,\n      value: (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n          throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n      }\n    });\n    const {\n      max = 0,\n      ttl: _ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale: _allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize: _maxSize2 = 0,\n      maxEntrySize = 0,\n      sizeCalculation: _sizeCalculation,\n      fetchMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort\n    } = _options;\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n    const UintArray = max ? getUintArray(max) : Array;\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n    _classPrivateFieldSet(this, _max, max);\n    _classPrivateFieldSet(this, _maxSize, _maxSize2);\n    this.maxEntrySize = maxEntrySize || _classPrivateFieldGet(this, _maxSize);\n    this.sizeCalculation = _sizeCalculation;\n    if (this.sizeCalculation) {\n      if (!_classPrivateFieldGet(this, _maxSize) && !this.maxEntrySize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n    if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n    _classPrivateFieldSet(this, _fetchMethod, fetchMethod);\n    _classPrivateFieldSet(this, _hasFetchMethod, !!fetchMethod);\n    _classPrivateFieldSet(this, _keyMap, new Map());\n    _classPrivateFieldSet(this, _keyList, new Array(max).fill(undefined));\n    _classPrivateFieldSet(this, _valList, new Array(max).fill(undefined));\n    _classPrivateFieldSet(this, _next, new UintArray(max));\n    _classPrivateFieldSet(this, _prev, new UintArray(max));\n    _classPrivateFieldSet(this, _head, 0);\n    _classPrivateFieldSet(this, _tail, 0);\n    _classPrivateFieldSet(this, _free, Stack.create(max));\n    _classPrivateFieldSet(this, _size, 0);\n    _classPrivateFieldSet(this, _calculatedSize, 0);\n    if (typeof dispose === 'function') {\n      _classPrivateFieldSet(this, _dispose, dispose);\n    }\n    if (typeof disposeAfter === 'function') {\n      _classPrivateFieldSet(this, _disposeAfter, disposeAfter);\n      _classPrivateFieldSet(this, _disposed, []);\n    } else {\n      _classPrivateFieldSet(this, _disposeAfter, undefined);\n      _classPrivateFieldSet(this, _disposed, undefined);\n    }\n    _classPrivateFieldSet(this, _hasDispose, !!_classPrivateFieldGet(this, _dispose));\n    _classPrivateFieldSet(this, _hasDisposeAfter, !!_classPrivateFieldGet(this, _disposeAfter));\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n    this.ignoreFetchAbort = !!ignoreFetchAbort;\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (_classPrivateFieldGet(this, _maxSize) !== 0) {\n        if (!isPosInt(_classPrivateFieldGet(this, _maxSize))) {\n          throw new TypeError('maxSize must be a positive integer if specified');\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError('maxEntrySize must be a positive integer if specified');\n      }\n      _classPrivateMethodGet(this, _initializeSizeTracking, _initializeSizeTracking2).call(this);\n    }\n    this.allowStale = !!_allowStale;\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = _ttl || 0;\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n      _classPrivateMethodGet(this, _initializeTTLTracking, _initializeTTLTracking2).call(this);\n    }\n    // do not allow completely unbounded caches\n    if (_classPrivateFieldGet(this, _max) === 0 && this.ttl === 0 && _classPrivateFieldGet(this, _maxSize) === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n    if (!this.ttlAutopurge && !_classPrivateFieldGet(this, _max) && !_classPrivateFieldGet(this, _maxSize)) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n  }\n  /**\n   * Return the remaining TTL time for a given entry key\n   */\n  getRemainingTTL(key) {\n    return _classPrivateFieldGet(this, _keyMap).has(key) ? Infinity : 0;\n  }\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      if (_classPrivateFieldGet(this, _valList)[i] !== undefined && _classPrivateFieldGet(this, _keyList)[i] !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield [_classPrivateFieldGet(this, _keyList)[i], _classPrivateFieldGet(this, _valList)[i]];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      if (_classPrivateFieldGet(this, _valList)[i] !== undefined && _classPrivateFieldGet(this, _keyList)[i] !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield [_classPrivateFieldGet(this, _keyList)[i], _classPrivateFieldGet(this, _valList)[i]];\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const k = _classPrivateFieldGet(this, _keyList)[i];\n      if (k !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const k = _classPrivateFieldGet(this, _keyList)[i];\n      if (k !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      if (v !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield _classPrivateFieldGet(this, _valList)[i];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      if (v !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield _classPrivateFieldGet(this, _valList)[i];\n      }\n    }\n  }\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [_Symbol$iterator]() {\n    return this.entries();\n  }\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to Array.find().  fn is called as fn(value, key, cache).\n   */\n  find(fn, getOptions = {}) {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      if (fn(value, _classPrivateFieldGet(this, _keyList)[i], this)) {\n        return this.get(_classPrivateFieldGet(this, _keyList)[i], getOptions);\n      }\n    }\n  }\n  /**\n   * Call the supplied function on each item in the cache, in order from\n   * most recently used to least recently used.  fn is called as\n   * fn(value, key, cache).  Does not update age or recenty of use.\n   * Does not iterate over stale values.\n   */\n  forEach(fn, thisp = this) {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, _classPrivateFieldGet(this, _keyList)[i], this);\n    }\n  }\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(fn, thisp = this) {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, _classPrivateFieldGet(this, _keyList)[i], this);\n    }\n  }\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false;\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this, {\n      allowStale: true\n    })) {\n      if (_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        this.delete(_classPrivateFieldGet(this, _keyList)[i]);\n        deleted = true;\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to cache.load()\n   */\n  dump() {\n    const arr = [];\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this, {\n      allowStale: true\n    })) {\n      const key = _classPrivateFieldGet(this, _keyList)[i];\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined || key === undefined) continue;\n      const entry = {\n        value\n      };\n      if (_classPrivateFieldGet(this, _ttls) && _classPrivateFieldGet(this, _starts)) {\n        entry.ttl = _classPrivateFieldGet(this, _ttls)[i];\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - _classPrivateFieldGet(this, _starts)[i];\n        entry.start = Math.floor(Date.now() - age);\n      }\n      if (_classPrivateFieldGet(this, _sizes)) {\n        entry.size = _classPrivateFieldGet(this, _sizes)[i];\n      }\n      arr.unshift([key, entry]);\n    }\n    return arr;\n  }\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   * Note that the shape of the resulting cache may be different if the\n   * same options are not used in both caches.\n   */\n  load(arr) {\n    this.clear();\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start;\n        entry.start = perf.now() - age;\n      }\n      this.set(key, entry.value, entry);\n    }\n  }\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   */\n  set(k, v, setOptions = {}) {\n    if (v === undefined) {\n      this.delete(k);\n      return this;\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status\n    } = setOptions;\n    let {\n      noUpdateTTL = this.noUpdateTTL\n    } = setOptions;\n    const size = _classPrivateFieldGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss';\n        status.maxEntrySizeExceeded = true;\n      }\n      // have to delete, in case something is there already.\n      this.delete(k);\n      return this;\n    }\n    let index = _classPrivateFieldGet(this, _size) === 0 ? undefined : _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index === undefined) {\n      var _this$size, _this$size2;\n      // addition\n      index = _classPrivateFieldGet(this, _size) === 0 ? _classPrivateFieldGet(this, _tail) : _classPrivateFieldGet(this, _free).length !== 0 ? _classPrivateFieldGet(this, _free).pop() : _classPrivateFieldGet(this, _size) === _classPrivateFieldGet(this, _max) ? _classPrivateMethodGet(this, _evict, _evict2).call(this, false) : _classPrivateFieldGet(this, _size);\n      _classPrivateFieldGet(this, _keyList)[index] = k;\n      _classPrivateFieldGet(this, _valList)[index] = v;\n      _classPrivateFieldGet(this, _keyMap).set(k, index);\n      _classPrivateFieldGet(this, _next)[_classPrivateFieldGet(this, _tail)] = index;\n      _classPrivateFieldGet(this, _prev)[index] = _classPrivateFieldGet(this, _tail);\n      _classPrivateFieldSet(this, _tail, index);\n      _classPrivateFieldSet(this, _size, (_this$size = _classPrivateFieldGet(this, _size), _this$size2 = _this$size++, _this$size)), _this$size2;\n      _classPrivateFieldGet(this, _addItemSize).call(this, index, size, status);\n      if (status) status.set = 'add';\n      noUpdateTTL = false;\n    } else {\n      // update\n      _classPrivateMethodGet(this, _moveToTail, _moveToTail2).call(this, index);\n      const oldVal = _classPrivateFieldGet(this, _valList)[index];\n      if (v !== oldVal) {\n        if (_classPrivateFieldGet(this, _hasFetchMethod) && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'));\n          const {\n            __staleWhileFetching: s\n          } = oldVal;\n          if (s !== undefined && !noDisposeOnSet) {\n            if (_classPrivateFieldGet(this, _hasDispose)) {\n              _classPrivateFieldGet(this, _dispose)?.call(this, s, k, 'set');\n            }\n            if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n              _classPrivateFieldGet(this, _disposed)?.push([s, k, 'set']);\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (_classPrivateFieldGet(this, _hasDispose)) {\n            _classPrivateFieldGet(this, _dispose)?.call(this, oldVal, k, 'set');\n          }\n          if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n            _classPrivateFieldGet(this, _disposed)?.push([oldVal, k, 'set']);\n          }\n        }\n        _classPrivateFieldGet(this, _removeItemSize).call(this, index);\n        _classPrivateFieldGet(this, _addItemSize).call(this, index, size, status);\n        _classPrivateFieldGet(this, _valList)[index] = v;\n        if (status) {\n          status.set = 'replace';\n          const oldValue = oldVal && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;\n          if (oldValue !== undefined) status.oldValue = oldValue;\n        }\n      } else if (status) {\n        status.set = 'update';\n      }\n    }\n    if (ttl !== 0 && !_classPrivateFieldGet(this, _ttls)) {\n      _classPrivateMethodGet(this, _initializeTTLTracking, _initializeTTLTracking2).call(this);\n    }\n    if (_classPrivateFieldGet(this, _ttls)) {\n      if (!noUpdateTTL) {\n        _classPrivateFieldGet(this, _setItemTTL).call(this, index, ttl, start);\n      }\n      if (status) _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n    }\n    if (!noDisposeOnSet && _classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n    return this;\n  }\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop() {\n    try {\n      while (_classPrivateFieldGet(this, _size)) {\n        const val = _classPrivateFieldGet(this, _valList)[_classPrivateFieldGet(this, _head)];\n        _classPrivateMethodGet(this, _evict, _evict2).call(this, true);\n        if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching;\n          }\n        } else if (val !== undefined) {\n          return val;\n        }\n      }\n    } finally {\n      if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n        const dt = _classPrivateFieldGet(this, _disposed);\n        let task;\n        while (task = dt?.shift()) {\n          _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n        }\n      }\n    }\n  }\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k, hasOptions = {}) {\n    const {\n      updateAgeOnHas = this.updateAgeOnHas,\n      status\n    } = hasOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) && v.__staleWhileFetching === undefined) {\n        return false;\n      }\n      if (!_classPrivateFieldGet(this, _isStale).call(this, index)) {\n        if (updateAgeOnHas) {\n          _classPrivateFieldGet(this, _updateItemAge).call(this, index);\n        }\n        if (status) {\n          status.has = 'hit';\n          _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n        }\n        return true;\n      } else if (status) {\n        status.has = 'stale';\n        _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n      }\n    } else if (status) {\n      status.has = 'miss';\n    }\n    return false;\n  }\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k, peekOptions = {}) {\n    const {\n      allowStale = this.allowStale\n    } = peekOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined && (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, index))) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n    }\n  }\n  fetch(k, fetchOptions = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        // get options\n        allowStale = _this.allowStale,\n        updateAgeOnGet = _this.updateAgeOnGet,\n        noDeleteOnStaleGet = _this.noDeleteOnStaleGet,\n        // set options\n        ttl = _this.ttl,\n        noDisposeOnSet = _this.noDisposeOnSet,\n        size = 0,\n        sizeCalculation = _this.sizeCalculation,\n        noUpdateTTL = _this.noUpdateTTL,\n        // fetch exclusive options\n        noDeleteOnFetchRejection = _this.noDeleteOnFetchRejection,\n        allowStaleOnFetchRejection = _this.allowStaleOnFetchRejection,\n        ignoreFetchAbort = _this.ignoreFetchAbort,\n        allowStaleOnFetchAbort = _this.allowStaleOnFetchAbort,\n        context,\n        forceRefresh = false,\n        status,\n        signal\n      } = fetchOptions;\n      if (!_classPrivateFieldGet(_this, _hasFetchMethod)) {\n        if (status) status.fetch = 'get';\n        return _this.get(k, {\n          allowStale,\n          updateAgeOnGet,\n          noDeleteOnStaleGet,\n          status\n        });\n      }\n      const options = {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        ttl,\n        noDisposeOnSet,\n        size,\n        sizeCalculation,\n        noUpdateTTL,\n        noDeleteOnFetchRejection,\n        allowStaleOnFetchRejection,\n        allowStaleOnFetchAbort,\n        ignoreFetchAbort,\n        status,\n        signal\n      };\n      let index = _classPrivateFieldGet(_this, _keyMap).get(k);\n      if (index === undefined) {\n        if (status) status.fetch = 'miss';\n        const p = _classPrivateMethodGet(_this, _backgroundFetch, _backgroundFetch2).call(_this, k, index, options, context);\n        return p.__returned = p;\n      } else {\n        // in cache, maybe already fetching\n        const v = _classPrivateFieldGet(_this, _valList)[index];\n        if (_classPrivateMethodGet(_this, _isBackgroundFetch, _isBackgroundFetch2).call(_this, v)) {\n          const stale = allowStale && v.__staleWhileFetching !== undefined;\n          if (status) {\n            status.fetch = 'inflight';\n            if (stale) status.returnedStale = true;\n          }\n          return stale ? v.__staleWhileFetching : v.__returned = v;\n        }\n        // if we force a refresh, that means do NOT serve the cached value,\n        // unless we are already in the process of refreshing the cache.\n        const isStale = _classPrivateFieldGet(_this, _isStale).call(_this, index);\n        if (!forceRefresh && !isStale) {\n          if (status) status.fetch = 'hit';\n          _classPrivateMethodGet(_this, _moveToTail, _moveToTail2).call(_this, index);\n          if (updateAgeOnGet) {\n            _classPrivateFieldGet(_this, _updateItemAge).call(_this, index);\n          }\n          if (status) _classPrivateFieldGet(_this, _statusTTL).call(_this, status, index);\n          return v;\n        }\n        // ok, it is stale or a forced refresh, and not already fetching.\n        // refresh the cache.\n        const p = _classPrivateMethodGet(_this, _backgroundFetch, _backgroundFetch2).call(_this, k, index, options, context);\n        const hasStale = p.__staleWhileFetching !== undefined;\n        const staleVal = hasStale && allowStale;\n        if (status) {\n          status.fetch = isStale ? 'stale' : 'refresh';\n          if (staleVal && isStale) status.returnedStale = true;\n        }\n        return staleVal ? p.__staleWhileFetching : p.__returned = p;\n      }\n    })();\n  }\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k, getOptions = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status\n    } = getOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined) {\n      const value = _classPrivateFieldGet(this, _valList)[index];\n      const fetching = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, value);\n      if (status) _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n      if (_classPrivateFieldGet(this, _isStale).call(this, index)) {\n        if (status) status.get = 'stale';\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k);\n          }\n          if (status && allowStale) status.returnedStale = true;\n          return allowStale ? value : undefined;\n        } else {\n          if (status && allowStale && value.__staleWhileFetching !== undefined) {\n            status.returnedStale = true;\n          }\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        if (status) status.get = 'hit';\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching;\n        }\n        _classPrivateMethodGet(this, _moveToTail, _moveToTail2).call(this, index);\n        if (updateAgeOnGet) {\n          _classPrivateFieldGet(this, _updateItemAge).call(this, index);\n        }\n        return value;\n      }\n    } else if (status) {\n      status.get = 'miss';\n    }\n  }\n  /**\n   * Deletes a key out of the cache.\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k) {\n    let deleted = false;\n    if (_classPrivateFieldGet(this, _size) !== 0) {\n      const index = _classPrivateFieldGet(this, _keyMap).get(k);\n      if (index !== undefined) {\n        deleted = true;\n        if (_classPrivateFieldGet(this, _size) === 1) {\n          this.clear();\n        } else {\n          var _this$size5, _this$size6;\n          _classPrivateFieldGet(this, _removeItemSize).call(this, index);\n          const v = _classPrivateFieldGet(this, _valList)[index];\n          if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n            v.__abortController.abort(new Error('deleted'));\n          } else if (_classPrivateFieldGet(this, _hasDispose) || _classPrivateFieldGet(this, _hasDisposeAfter)) {\n            if (_classPrivateFieldGet(this, _hasDispose)) {\n              _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'delete');\n            }\n            if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n              _classPrivateFieldGet(this, _disposed)?.push([v, k, 'delete']);\n            }\n          }\n          _classPrivateFieldGet(this, _keyMap).delete(k);\n          _classPrivateFieldGet(this, _keyList)[index] = undefined;\n          _classPrivateFieldGet(this, _valList)[index] = undefined;\n          if (index === _classPrivateFieldGet(this, _tail)) {\n            _classPrivateFieldSet(this, _tail, _classPrivateFieldGet(this, _prev)[index]);\n          } else if (index === _classPrivateFieldGet(this, _head)) {\n            _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[index]);\n          } else {\n            _classPrivateFieldGet(this, _next)[_classPrivateFieldGet(this, _prev)[index]] = _classPrivateFieldGet(this, _next)[index];\n            _classPrivateFieldGet(this, _prev)[_classPrivateFieldGet(this, _next)[index]] = _classPrivateFieldGet(this, _prev)[index];\n          }\n          _classPrivateFieldSet(this, _size, (_this$size5 = _classPrivateFieldGet(this, _size), _this$size6 = _this$size5--, _this$size5)), _this$size6;\n          _classPrivateFieldGet(this, _free).push(index);\n        }\n      }\n    }\n    if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)?.length) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    for (const index of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this, {\n      allowStale: true\n    })) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n        v.__abortController.abort(new Error('deleted'));\n      } else {\n        const k = _classPrivateFieldGet(this, _keyList)[index];\n        if (_classPrivateFieldGet(this, _hasDispose)) {\n          _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'delete');\n        }\n        if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n          _classPrivateFieldGet(this, _disposed)?.push([v, k, 'delete']);\n        }\n      }\n    }\n    _classPrivateFieldGet(this, _keyMap).clear();\n    _classPrivateFieldGet(this, _valList).fill(undefined);\n    _classPrivateFieldGet(this, _keyList).fill(undefined);\n    if (_classPrivateFieldGet(this, _ttls) && _classPrivateFieldGet(this, _starts)) {\n      _classPrivateFieldGet(this, _ttls).fill(0);\n      _classPrivateFieldGet(this, _starts).fill(0);\n    }\n    if (_classPrivateFieldGet(this, _sizes)) {\n      _classPrivateFieldGet(this, _sizes).fill(0);\n    }\n    _classPrivateFieldSet(this, _head, 0);\n    _classPrivateFieldSet(this, _tail, 0);\n    _classPrivateFieldGet(this, _free).length = 0;\n    _classPrivateFieldSet(this, _calculatedSize, 0);\n    _classPrivateFieldSet(this, _size, 0);\n    if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n  }\n}\nfunction _initializeTTLTracking2() {\n  const ttls = new ZeroArray(_classPrivateFieldGet(this, _max));\n  const starts = new ZeroArray(_classPrivateFieldGet(this, _max));\n  _classPrivateFieldSet(this, _ttls, ttls);\n  _classPrivateFieldSet(this, _starts, starts);\n  _classPrivateFieldSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {\n    starts[index] = ttl !== 0 ? start : 0;\n    ttls[index] = ttl;\n    if (ttl !== 0 && this.ttlAutopurge) {\n      const t = setTimeout(() => {\n        if (_classPrivateFieldGet(this, _isStale).call(this, index)) {\n          this.delete(_classPrivateFieldGet(this, _keyList)[index]);\n        }\n      }, ttl + 1);\n      // unref() not supported on all platforms\n      /* c8 ignore start */\n      if (t.unref) {\n        t.unref();\n      }\n      /* c8 ignore stop */\n    }\n  });\n\n  _classPrivateFieldSet(this, _updateItemAge, index => {\n    starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n  });\n  _classPrivateFieldSet(this, _statusTTL, (status, index) => {\n    if (ttls[index]) {\n      const ttl = ttls[index];\n      const start = starts[index];\n      status.ttl = ttl;\n      status.start = start;\n      status.now = cachedNow || getNow();\n      const age = status.now - start;\n      status.remainingTTL = ttl - age;\n    }\n  });\n  // debounce calls to perf.now() to 1s so we're not hitting\n  // that costly call repeatedly.\n  let cachedNow = 0;\n  const getNow = () => {\n    const n = perf.now();\n    if (this.ttlResolution > 0) {\n      cachedNow = n;\n      const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n      // not available on all platforms\n      /* c8 ignore start */\n      if (t.unref) {\n        t.unref();\n      }\n      /* c8 ignore stop */\n    }\n\n    return n;\n  };\n  this.getRemainingTTL = key => {\n    const index = _classPrivateFieldGet(this, _keyMap).get(key);\n    if (index === undefined) {\n      return 0;\n    }\n    const ttl = ttls[index];\n    const start = starts[index];\n    if (ttl === 0 || start === 0) {\n      return Infinity;\n    }\n    const age = (cachedNow || getNow()) - start;\n    return ttl - age;\n  };\n  _classPrivateFieldSet(this, _isStale, index => {\n    return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];\n  });\n}\nfunction _initializeSizeTracking2() {\n  const sizes = new ZeroArray(_classPrivateFieldGet(this, _max));\n  _classPrivateFieldSet(this, _calculatedSize, 0);\n  _classPrivateFieldSet(this, _sizes, sizes);\n  _classPrivateFieldSet(this, _removeItemSize, index => {\n    _classPrivateFieldSet(this, _calculatedSize, _classPrivateFieldGet(this, _calculatedSize) - sizes[index]);\n    sizes[index] = 0;\n  });\n  _classPrivateFieldSet(this, _requireSize, (k, v, size, sizeCalculation) => {\n    // provisionally accept background fetches.\n    // actual value size will be checked when they return.\n    if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n      return 0;\n    }\n    if (!isPosInt(size)) {\n      if (sizeCalculation) {\n        if (typeof sizeCalculation !== 'function') {\n          throw new TypeError('sizeCalculation must be a function');\n        }\n        size = sizeCalculation(v, k);\n        if (!isPosInt(size)) {\n          throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n        }\n      } else {\n        throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');\n      }\n    }\n    return size;\n  });\n  _classPrivateFieldSet(this, _addItemSize, (index, size, status) => {\n    sizes[index] = size;\n    if (_classPrivateFieldGet(this, _maxSize)) {\n      const maxSize = _classPrivateFieldGet(this, _maxSize) - sizes[index];\n      while (_classPrivateFieldGet(this, _calculatedSize) > maxSize) {\n        _classPrivateMethodGet(this, _evict, _evict2).call(this, true);\n      }\n    }\n    _classPrivateFieldSet(this, _calculatedSize, _classPrivateFieldGet(this, _calculatedSize) + sizes[index]);\n    if (status) {\n      status.entrySize = size;\n      status.totalCalculatedSize = _classPrivateFieldGet(this, _calculatedSize);\n    }\n  });\n}\nfunction* _indexes2({\n  allowStale = this.allowStale\n} = {}) {\n  if (_classPrivateFieldGet(this, _size)) {\n    for (let i = _classPrivateFieldGet(this, _tail); true;) {\n      if (!_classPrivateMethodGet(this, _isValidIndex, _isValidIndex2).call(this, i)) {\n        break;\n      }\n      if (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        yield i;\n      }\n      if (i === _classPrivateFieldGet(this, _head)) {\n        break;\n      } else {\n        i = _classPrivateFieldGet(this, _prev)[i];\n      }\n    }\n  }\n}\nfunction* _rindexes2({\n  allowStale = this.allowStale\n} = {}) {\n  if (_classPrivateFieldGet(this, _size)) {\n    for (let i = _classPrivateFieldGet(this, _head); true;) {\n      if (!_classPrivateMethodGet(this, _isValidIndex, _isValidIndex2).call(this, i)) {\n        break;\n      }\n      if (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        yield i;\n      }\n      if (i === _classPrivateFieldGet(this, _tail)) {\n        break;\n      } else {\n        i = _classPrivateFieldGet(this, _next)[i];\n      }\n    }\n  }\n}\nfunction _isValidIndex2(index) {\n  return index !== undefined && _classPrivateFieldGet(this, _keyMap).get(_classPrivateFieldGet(this, _keyList)[index]) === index;\n}\nfunction _evict2(free) {\n  var _this$size3, _this$size4;\n  const head = _classPrivateFieldGet(this, _head);\n  const k = _classPrivateFieldGet(this, _keyList)[head];\n  const v = _classPrivateFieldGet(this, _valList)[head];\n  if (_classPrivateFieldGet(this, _hasFetchMethod) && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n    v.__abortController.abort(new Error('evicted'));\n  } else if (_classPrivateFieldGet(this, _hasDispose) || _classPrivateFieldGet(this, _hasDisposeAfter)) {\n    if (_classPrivateFieldGet(this, _hasDispose)) {\n      _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'evict');\n    }\n    if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n      _classPrivateFieldGet(this, _disposed)?.push([v, k, 'evict']);\n    }\n  }\n  _classPrivateFieldGet(this, _removeItemSize).call(this, head);\n  // if we aren't about to use the index, then null these out\n  if (free) {\n    _classPrivateFieldGet(this, _keyList)[head] = undefined;\n    _classPrivateFieldGet(this, _valList)[head] = undefined;\n    _classPrivateFieldGet(this, _free).push(head);\n  }\n  if (_classPrivateFieldGet(this, _size) === 1) {\n    _classPrivateFieldSet(this, _head, _classPrivateFieldSet(this, _tail, 0));\n    _classPrivateFieldGet(this, _free).length = 0;\n  } else {\n    _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[head]);\n  }\n  _classPrivateFieldGet(this, _keyMap).delete(k);\n  _classPrivateFieldSet(this, _size, (_this$size3 = _classPrivateFieldGet(this, _size), _this$size4 = _this$size3--, _this$size3)), _this$size4;\n  return head;\n}\nfunction _backgroundFetch2(k, index, options, context) {\n  const v = index === undefined ? undefined : _classPrivateFieldGet(this, _valList)[index];\n  if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n    return v;\n  }\n  const ac = new AC();\n  const {\n    signal\n  } = options;\n  // when/if our AC signals, then stop listening to theirs.\n  signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n    signal: ac.signal\n  });\n  const fetchOpts = {\n    signal: ac.signal,\n    options,\n    context\n  };\n  const cb = (v, updateCache = false) => {\n    const {\n      aborted\n    } = ac.signal;\n    const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n    if (options.status) {\n      if (aborted && !updateCache) {\n        options.status.fetchAborted = true;\n        options.status.fetchError = ac.signal.reason;\n        if (ignoreAbort) options.status.fetchAbortIgnored = true;\n      } else {\n        options.status.fetchResolved = true;\n      }\n    }\n    if (aborted && !ignoreAbort && !updateCache) {\n      return fetchFail(ac.signal.reason);\n    }\n    // either we didn't abort, and are still here, or we did, and ignored\n    const bf = p;\n    if (_classPrivateFieldGet(this, _valList)[index] === p) {\n      if (v === undefined) {\n        if (bf.__staleWhileFetching) {\n          _classPrivateFieldGet(this, _valList)[index] = bf.__staleWhileFetching;\n        } else {\n          this.delete(k);\n        }\n      } else {\n        if (options.status) options.status.fetchUpdated = true;\n        this.set(k, v, fetchOpts.options);\n      }\n    }\n    return v;\n  };\n  const eb = er => {\n    if (options.status) {\n      options.status.fetchRejected = true;\n      options.status.fetchError = er;\n    }\n    return fetchFail(er);\n  };\n  const fetchFail = er => {\n    const {\n      aborted\n    } = ac.signal;\n    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n    const noDelete = allowStale || options.noDeleteOnFetchRejection;\n    const bf = p;\n    if (_classPrivateFieldGet(this, _valList)[index] === p) {\n      // if we allow stale on fetch rejections, then we need to ensure that\n      // the stale value is not removed from the cache when the fetch fails.\n      const del = !noDelete || bf.__staleWhileFetching === undefined;\n      if (del) {\n        this.delete(k);\n      } else if (!allowStaleAborted) {\n        // still replace the *promise* with the stale value,\n        // since we are done with the promise at this point.\n        // leave it untouched if we're still waiting for an\n        // aborted background fetch that hasn't yet returned.\n        _classPrivateFieldGet(this, _valList)[index] = bf.__staleWhileFetching;\n      }\n    }\n    if (allowStale) {\n      if (options.status && bf.__staleWhileFetching !== undefined) {\n        options.status.returnedStale = true;\n      }\n      return bf.__staleWhileFetching;\n    } else if (bf.__returned === bf) {\n      throw er;\n    }\n  };\n  const pcall = (res, rej) => {\n    const fmp = _classPrivateFieldGet(this, _fetchMethod)?.call(this, k, v, fetchOpts);\n    if (fmp && fmp instanceof Promise) {\n      fmp.then(v => res(v === undefined ? undefined : v), rej);\n    }\n    // ignored, we go until we finish, regardless.\n    // defer check until we are actually aborting,\n    // so fetchMethod can override.\n    ac.signal.addEventListener('abort', () => {\n      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n        res(undefined);\n        // when it eventually resolves, update the cache.\n        if (options.allowStaleOnFetchAbort) {\n          res = v => cb(v, true);\n        }\n      }\n    });\n  };\n  if (options.status) options.status.fetchDispatched = true;\n  const p = new Promise(pcall).then(cb, eb);\n  const bf = Object.assign(p, {\n    __abortController: ac,\n    __staleWhileFetching: v,\n    __returned: undefined\n  });\n  if (index === undefined) {\n    // internal, don't expose status.\n    this.set(k, bf, {\n      ...fetchOpts.options,\n      status: undefined\n    });\n    index = _classPrivateFieldGet(this, _keyMap).get(k);\n  } else {\n    _classPrivateFieldGet(this, _valList)[index] = bf;\n  }\n  return bf;\n}\nfunction _isBackgroundFetch2(p) {\n  if (!_classPrivateFieldGet(this, _hasFetchMethod)) return false;\n  const b = p;\n  return !!b && b instanceof Promise && b.hasOwnProperty('__staleWhileFetching') && b.__abortController instanceof AC;\n}\nfunction _connect2(p, n) {\n  _classPrivateFieldGet(this, _prev)[n] = p;\n  _classPrivateFieldGet(this, _next)[p] = n;\n}\nfunction _moveToTail2(index) {\n  // if tail already, nothing to do\n  // if head, move head to next[index]\n  // else\n  //   move next[prev[index]] to next[index] (head has no prev)\n  //   move prev[next[index]] to prev[index]\n  // prev[index] = tail\n  // next[tail] = index\n  // tail = index\n  if (index !== _classPrivateFieldGet(this, _tail)) {\n    if (index === _classPrivateFieldGet(this, _head)) {\n      _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[index]);\n    } else {\n      _classPrivateMethodGet(this, _connect, _connect2).call(this, _classPrivateFieldGet(this, _prev)[index], _classPrivateFieldGet(this, _next)[index]);\n    }\n    _classPrivateMethodGet(this, _connect, _connect2).call(this, _classPrivateFieldGet(this, _tail), index);\n    _classPrivateFieldSet(this, _tail, index);\n  }\n}\nexports.LRUCache = LRUCache;\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}