{"ast":null,"code":"import _asyncToGenerator from \"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// pkg/dist-src/index.js\nimport { endpoint } from \"@octokit/endpoint\";\nimport { getUserAgent } from \"universal-user-agent\";\n\n// pkg/dist-src/version.js\nvar VERSION = \"8.1.2\";\n\n// pkg/dist-src/fetch-wrapper.js\nimport { isPlainObject } from \"is-plain-object\";\nimport { RequestError } from \"@octokit/request-error\";\n\n// pkg/dist-src/get-buffer-response.js\nfunction getBufferResponse(response) {\n  return response.arrayBuffer();\n}\n\n// pkg/dist-src/fetch-wrapper.js\nfunction fetchWrapper(requestOptions) {\n  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;\n  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;\n  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {\n    requestOptions.body = JSON.stringify(requestOptions.body);\n  }\n  let headers = {};\n  let status;\n  let url;\n  let {\n    fetch\n  } = globalThis;\n  if (requestOptions.request?.fetch) {\n    fetch = requestOptions.request.fetch;\n  }\n  if (!fetch) {\n    throw new Error(\"fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing\");\n  }\n  return fetch(requestOptions.url, {\n    method: requestOptions.method,\n    body: requestOptions.body,\n    headers: requestOptions.headers,\n    signal: requestOptions.request?.signal,\n    // duplex must be set if request.body is ReadableStream or Async Iterables.\n    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.\n    ...(requestOptions.body && {\n      duplex: \"half\"\n    })\n  }).then( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (response) {\n      url = response.url;\n      status = response.status;\n      for (const keyAndValue of response.headers) {\n        headers[keyAndValue[0]] = keyAndValue[1];\n      }\n      if (\"deprecation\" in headers) {\n        const matches = headers.link && headers.link.match(/<([^>]+)>; rel=\"deprecation\"/);\n        const deprecationLink = matches && matches.pop();\n        log.warn(`[@octokit/request] \"${requestOptions.method} ${requestOptions.url}\" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : \"\"}`);\n      }\n      if (status === 204 || status === 205) {\n        return;\n      }\n      if (requestOptions.method === \"HEAD\") {\n        if (status < 400) {\n          return;\n        }\n        throw new RequestError(response.statusText, status, {\n          response: {\n            url,\n            status,\n            headers,\n            data: void 0\n          },\n          request: requestOptions\n        });\n      }\n      if (status === 304) {\n        throw new RequestError(\"Not modified\", status, {\n          response: {\n            url,\n            status,\n            headers,\n            data: yield getResponseData(response)\n          },\n          request: requestOptions\n        });\n      }\n      if (status >= 400) {\n        const data = yield getResponseData(response);\n        const error = new RequestError(toErrorMessage(data), status, {\n          response: {\n            url,\n            status,\n            headers,\n            data\n          },\n          request: requestOptions\n        });\n        throw error;\n      }\n      return parseSuccessResponseBody ? yield getResponseData(response) : response.body;\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()).then(data => {\n    return {\n      status,\n      url,\n      headers,\n      data\n    };\n  }).catch(error => {\n    if (error instanceof RequestError) throw error;else if (error.name === \"AbortError\") throw error;\n    throw new RequestError(error.message, 500, {\n      request: requestOptions\n    });\n  });\n}\nfunction getResponseData(_x2) {\n  return _getResponseData.apply(this, arguments);\n}\nfunction _getResponseData() {\n  _getResponseData = _asyncToGenerator(function* (response) {\n    const contentType = response.headers.get(\"content-type\");\n    if (/application\\/json/.test(contentType)) {\n      return response.json();\n    }\n    if (!contentType || /^text\\/|charset=utf-8$/.test(contentType)) {\n      return response.text();\n    }\n    return getBufferResponse(response);\n  });\n  return _getResponseData.apply(this, arguments);\n}\nfunction toErrorMessage(data) {\n  if (typeof data === \"string\") return data;\n  if (\"message\" in data) {\n    if (Array.isArray(data.errors)) {\n      return `${data.message}: ${data.errors.map(JSON.stringify).join(\", \")}`;\n    }\n    return data.message;\n  }\n  return `Unknown error: ${JSON.stringify(data)}`;\n}\n\n// pkg/dist-src/with-defaults.js\nfunction withDefaults(oldEndpoint, newDefaults) {\n  const endpoint2 = oldEndpoint.defaults(newDefaults);\n  const newApi = function (route, parameters) {\n    const endpointOptions = endpoint2.merge(route, parameters);\n    if (!endpointOptions.request || !endpointOptions.request.hook) {\n      return fetchWrapper(endpoint2.parse(endpointOptions));\n    }\n    const request2 = (route2, parameters2) => {\n      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));\n    };\n    Object.assign(request2, {\n      endpoint: endpoint2,\n      defaults: withDefaults.bind(null, endpoint2)\n    });\n    return endpointOptions.request.hook(request2, endpointOptions);\n  };\n  return Object.assign(newApi, {\n    endpoint: endpoint2,\n    defaults: withDefaults.bind(null, endpoint2)\n  });\n}\n\n// pkg/dist-src/index.js\nvar request = withDefaults(endpoint, {\n  headers: {\n    \"user-agent\": `octokit-request.js/${VERSION} ${getUserAgent()}`\n  }\n});\nexport { request };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}