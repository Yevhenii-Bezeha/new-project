{"ast":null,"code":"import _asyncToGenerator from \"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n// pkg/dist-src/index.js\nimport { Octokit as Octokit3 } from \"@octokit/core\";\n\n// pkg/dist-src/errors.js\nvar generateMessage = (path, cursorValue) => `The cursor at \"${path.join(\",\")}\" did not change its value \"${cursorValue}\" after a page transition. Please make sure your that your query is set up correctly.`;\nvar MissingCursorChange = class extends Error {\n  constructor(pageInfo, cursorValue) {\n    super(generateMessage(pageInfo.pathInQuery, cursorValue));\n    this.pageInfo = pageInfo;\n    this.cursorValue = cursorValue;\n    this.name = \"MissingCursorChangeError\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n};\nvar MissingPageInfo = class extends Error {\n  constructor(response) {\n    super(`No pageInfo property found in response. Please make sure to specify the pageInfo in your query. Response-Data: ${JSON.stringify(response, null, 2)}`);\n    this.response = response;\n    this.name = \"MissingPageInfo\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n};\n\n// pkg/dist-src/object-helpers.js\nvar isObject = value => Object.prototype.toString.call(value) === \"[object Object]\";\nfunction findPaginatedResourcePath(responseData) {\n  const paginatedResourcePath = deepFindPathToProperty(responseData, \"pageInfo\");\n  if (paginatedResourcePath.length === 0) {\n    throw new MissingPageInfo(responseData);\n  }\n  return paginatedResourcePath;\n}\nvar deepFindPathToProperty = (object, searchProp, path = []) => {\n  for (const key of Object.keys(object)) {\n    const currentPath = [...path, key];\n    const currentValue = object[key];\n    if (currentValue.hasOwnProperty(searchProp)) {\n      return currentPath;\n    }\n    if (isObject(currentValue)) {\n      const result = deepFindPathToProperty(currentValue, searchProp, currentPath);\n      if (result.length > 0) {\n        return result;\n      }\n    }\n  }\n  return [];\n};\nvar get = (object, path) => {\n  return path.reduce((current, nextProperty) => current[nextProperty], object);\n};\nvar set = (object, path, mutator) => {\n  const lastProperty = path[path.length - 1];\n  const parentPath = [...path].slice(0, -1);\n  const parent = get(object, parentPath);\n  if (typeof mutator === \"function\") {\n    parent[lastProperty] = mutator(parent[lastProperty]);\n  } else {\n    parent[lastProperty] = mutator;\n  }\n};\n\n// pkg/dist-src/extract-page-info.js\nvar extractPageInfos = responseData => {\n  const pageInfoPath = findPaginatedResourcePath(responseData);\n  return {\n    pathInQuery: pageInfoPath,\n    pageInfo: get(responseData, [...pageInfoPath, \"pageInfo\"])\n  };\n};\n\n// pkg/dist-src/iterator.js\nimport { Octokit } from \"@octokit/core\";\n\n// pkg/dist-src/page-info.js\nvar isForwardSearch = givenPageInfo => {\n  return givenPageInfo.hasOwnProperty(\"hasNextPage\");\n};\nvar getCursorFrom = pageInfo => isForwardSearch(pageInfo) ? pageInfo.endCursor : pageInfo.startCursor;\nvar hasAnotherPage = pageInfo => isForwardSearch(pageInfo) ? pageInfo.hasNextPage : pageInfo.hasPreviousPage;\n\n// pkg/dist-src/iterator.js\nvar createIterator = octokit => {\n  return (query, initialParameters = {}) => {\n    let nextPageExists = true;\n    let parameters = {\n      ...initialParameters\n    };\n    return {\n      [Symbol.asyncIterator]: () => ({\n        next() {\n          return _asyncToGenerator(function* () {\n            if (!nextPageExists) return {\n              done: true,\n              value: {}\n            };\n            const response = yield octokit.graphql(query, parameters);\n            const pageInfoContext = extractPageInfos(response);\n            const nextCursorValue = getCursorFrom(pageInfoContext.pageInfo);\n            nextPageExists = hasAnotherPage(pageInfoContext.pageInfo);\n            if (nextPageExists && nextCursorValue === parameters.cursor) {\n              throw new MissingCursorChange(pageInfoContext, nextCursorValue);\n            }\n            parameters = {\n              ...parameters,\n              cursor: nextCursorValue\n            };\n            return {\n              done: false,\n              value: response\n            };\n          })();\n        }\n      })\n    };\n  };\n};\n\n// pkg/dist-src/paginate.js\nimport { Octokit as Octokit2 } from \"@octokit/core\";\n\n// pkg/dist-src/merge-responses.js\nvar mergeResponses = (response1, response2) => {\n  if (Object.keys(response1).length === 0) {\n    return Object.assign(response1, response2);\n  }\n  const path = findPaginatedResourcePath(response1);\n  const nodesPath = [...path, \"nodes\"];\n  const newNodes = get(response2, nodesPath);\n  if (newNodes) {\n    set(response1, nodesPath, values => {\n      return [...values, ...newNodes];\n    });\n  }\n  const edgesPath = [...path, \"edges\"];\n  const newEdges = get(response2, edgesPath);\n  if (newEdges) {\n    set(response1, edgesPath, values => {\n      return [...values, ...newEdges];\n    });\n  }\n  const pageInfoPath = [...path, \"pageInfo\"];\n  set(response1, pageInfoPath, get(response2, pageInfoPath));\n  return response1;\n};\n\n// pkg/dist-src/paginate.js\nvar createPaginate = octokit => {\n  const iterator = createIterator(octokit);\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (query, initialParameters = {}) {\n      let mergedResponse = {};\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(iterator(query, initialParameters)), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const response = _step.value;\n          {\n            mergedResponse = mergeResponses(mergedResponse, response);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return mergedResponse;\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\n// pkg/dist-src/index.js\nfunction paginateGraphql(octokit) {\n  octokit.graphql;\n  return {\n    graphql: Object.assign(octokit.graphql, {\n      paginate: Object.assign(createPaginate(octokit), {\n        iterator: createIterator(octokit)\n      })\n    })\n  };\n}\nexport { paginateGraphql };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}