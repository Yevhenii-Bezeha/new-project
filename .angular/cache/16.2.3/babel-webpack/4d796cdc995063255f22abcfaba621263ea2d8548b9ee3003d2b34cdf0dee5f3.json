{"ast":null,"code":"import _asyncToGenerator from \"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// pkg/dist-src/index.js\nimport { getUserAgent } from \"universal-user-agent\";\nimport { request as octokitRequest } from \"@octokit/request\";\n\n// pkg/dist-src/get-oauth-access-token.js\nimport { createDeviceCode, exchangeDeviceCode } from \"@octokit/oauth-methods\";\nfunction getOAuthAccessToken(_x, _x2) {\n  return _getOAuthAccessToken.apply(this, arguments);\n}\nfunction _getOAuthAccessToken() {\n  _getOAuthAccessToken = _asyncToGenerator(function* (state, options) {\n    const cachedAuthentication = getCachedAuthentication(state, options.auth);\n    if (cachedAuthentication) return cachedAuthentication;\n    const {\n      data: verification\n    } = yield createDeviceCode({\n      clientType: state.clientType,\n      clientId: state.clientId,\n      request: options.request || state.request,\n      // @ts-expect-error the extra code to make TS happy is not worth it\n      scopes: options.auth.scopes || state.scopes\n    });\n    yield state.onVerification(verification);\n    const authentication = yield waitForAccessToken(options.request || state.request, state.clientId, state.clientType, verification);\n    state.authentication = authentication;\n    return authentication;\n  });\n  return _getOAuthAccessToken.apply(this, arguments);\n}\nfunction getCachedAuthentication(state, auth2) {\n  if (auth2.refresh === true) return false;\n  if (!state.authentication) return false;\n  if (state.clientType === \"github-app\") {\n    return state.authentication;\n  }\n  const authentication = state.authentication;\n  const newScope = (\"scopes\" in auth2 && auth2.scopes || state.scopes).join(\" \");\n  const currentScope = authentication.scopes.join(\" \");\n  return newScope === currentScope ? authentication : false;\n}\nfunction wait(_x3) {\n  return _wait.apply(this, arguments);\n}\nfunction _wait() {\n  _wait = _asyncToGenerator(function* (seconds) {\n    yield new Promise(resolve => setTimeout(resolve, seconds * 1e3));\n  });\n  return _wait.apply(this, arguments);\n}\nfunction waitForAccessToken(_x4, _x5, _x6, _x7) {\n  return _waitForAccessToken.apply(this, arguments);\n} // pkg/dist-src/auth.js\nfunction _waitForAccessToken() {\n  _waitForAccessToken = _asyncToGenerator(function* (request, clientId, clientType, verification) {\n    try {\n      const options = {\n        clientId,\n        request,\n        code: verification.device_code\n      };\n      const {\n        authentication\n      } = clientType === \"oauth-app\" ? yield exchangeDeviceCode({\n        ...options,\n        clientType: \"oauth-app\"\n      }) : yield exchangeDeviceCode({\n        ...options,\n        clientType: \"github-app\"\n      });\n      return {\n        type: \"token\",\n        tokenType: \"oauth\",\n        ...authentication\n      };\n    } catch (error) {\n      if (!error.response) throw error;\n      const errorType = error.response.data.error;\n      if (errorType === \"authorization_pending\") {\n        yield wait(verification.interval);\n        return waitForAccessToken(request, clientId, clientType, verification);\n      }\n      if (errorType === \"slow_down\") {\n        yield wait(verification.interval + 5);\n        return waitForAccessToken(request, clientId, clientType, verification);\n      }\n      throw error;\n    }\n  });\n  return _waitForAccessToken.apply(this, arguments);\n}\nfunction auth(_x8, _x9) {\n  return _auth.apply(this, arguments);\n} // pkg/dist-src/hook.js\nfunction _auth() {\n  _auth = _asyncToGenerator(function* (state, authOptions) {\n    return getOAuthAccessToken(state, {\n      auth: authOptions\n    });\n  });\n  return _auth.apply(this, arguments);\n}\nfunction hook(_x10, _x11, _x12, _x13) {\n  return _hook.apply(this, arguments);\n} // pkg/dist-src/version.js\nfunction _hook() {\n  _hook = _asyncToGenerator(function* (state, request, route, parameters) {\n    let endpoint = request.endpoint.merge(route, parameters);\n    if (/\\/login\\/(oauth\\/access_token|device\\/code)$/.test(endpoint.url)) {\n      return request(endpoint);\n    }\n    const {\n      token\n    } = yield getOAuthAccessToken(state, {\n      request,\n      auth: {\n        type: \"oauth\"\n      }\n    });\n    endpoint.headers.authorization = `token ${token}`;\n    return request(endpoint);\n  });\n  return _hook.apply(this, arguments);\n}\nvar VERSION = \"6.0.0\";\n\n// pkg/dist-src/index.js\nfunction createOAuthDeviceAuth(options) {\n  const requestWithDefaults = options.request || octokitRequest.defaults({\n    headers: {\n      \"user-agent\": `octokit-auth-oauth-device.js/${VERSION} ${getUserAgent()}`\n    }\n  });\n  const {\n    request = requestWithDefaults,\n    ...otherOptions\n  } = options;\n  const state = options.clientType === \"github-app\" ? {\n    ...otherOptions,\n    clientType: \"github-app\",\n    request\n  } : {\n    ...otherOptions,\n    clientType: \"oauth-app\",\n    request,\n    scopes: options.scopes || []\n  };\n  if (!options.clientId) {\n    throw new Error('[@octokit/auth-oauth-device] \"clientId\" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)');\n  }\n  if (!options.onVerification) {\n    throw new Error('[@octokit/auth-oauth-device] \"onVerification\" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)');\n  }\n  return Object.assign(auth.bind(null, state), {\n    hook: hook.bind(null, state)\n  });\n}\nexport { createOAuthDeviceAuth };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}