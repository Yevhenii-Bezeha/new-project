{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n/**\n  * This file contains the Bottleneck library (MIT), compiled to ES2017, and without Clustering support.\n  * https://github.com/SGrondin/bottleneck\n  */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Bottleneck = factory();\n})(this, function () {\n  'use strict';\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n  function getCjsExportFromNamespace(n) {\n    return n && n['default'] || n;\n  }\n  var load = function (received, defaults, onto = {}) {\n    var k, ref, v;\n    for (k in defaults) {\n      v = defaults[k];\n      onto[k] = (ref = received[k]) != null ? ref : v;\n    }\n    return onto;\n  };\n  var overwrite = function (received, defaults, onto = {}) {\n    var k, v;\n    for (k in received) {\n      v = received[k];\n      if (defaults[k] !== void 0) {\n        onto[k] = v;\n      }\n    }\n    return onto;\n  };\n  var parser = {\n    load: load,\n    overwrite: overwrite\n  };\n  var DLList;\n  DLList = class DLList {\n    constructor(incr, decr) {\n      this.incr = incr;\n      this.decr = decr;\n      this._first = null;\n      this._last = null;\n      this.length = 0;\n    }\n    push(value) {\n      var node;\n      this.length++;\n      if (typeof this.incr === \"function\") {\n        this.incr();\n      }\n      node = {\n        value,\n        prev: this._last,\n        next: null\n      };\n      if (this._last != null) {\n        this._last.next = node;\n        this._last = node;\n      } else {\n        this._first = this._last = node;\n      }\n      return void 0;\n    }\n    shift() {\n      var value;\n      if (this._first == null) {\n        return;\n      } else {\n        this.length--;\n        if (typeof this.decr === \"function\") {\n          this.decr();\n        }\n      }\n      value = this._first.value;\n      if ((this._first = this._first.next) != null) {\n        this._first.prev = null;\n      } else {\n        this._last = null;\n      }\n      return value;\n    }\n    first() {\n      if (this._first != null) {\n        return this._first.value;\n      }\n    }\n    getArray() {\n      var node, ref, results;\n      node = this._first;\n      results = [];\n      while (node != null) {\n        results.push((ref = node, node = node.next, ref.value));\n      }\n      return results;\n    }\n    forEachShift(cb) {\n      var node;\n      node = this.shift();\n      while (node != null) {\n        cb(node), node = this.shift();\n      }\n      return void 0;\n    }\n    debug() {\n      var node, ref, ref1, ref2, results;\n      node = this._first;\n      results = [];\n      while (node != null) {\n        results.push((ref = node, node = node.next, {\n          value: ref.value,\n          prev: (ref1 = ref.prev) != null ? ref1.value : void 0,\n          next: (ref2 = ref.next) != null ? ref2.value : void 0\n        }));\n      }\n      return results;\n    }\n  };\n  var DLList_1 = DLList;\n  var Events;\n  Events = class Events {\n    constructor(instance) {\n      this.instance = instance;\n      this._events = {};\n      if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {\n        throw new Error(\"An Emitter already exists for this object\");\n      }\n      this.instance.on = (name, cb) => {\n        return this._addListener(name, \"many\", cb);\n      };\n      this.instance.once = (name, cb) => {\n        return this._addListener(name, \"once\", cb);\n      };\n      this.instance.removeAllListeners = (name = null) => {\n        if (name != null) {\n          return delete this._events[name];\n        } else {\n          return this._events = {};\n        }\n      };\n    }\n    _addListener(name, status, cb) {\n      var base;\n      if ((base = this._events)[name] == null) {\n        base[name] = [];\n      }\n      this._events[name].push({\n        cb,\n        status\n      });\n      return this.instance;\n    }\n    listenerCount(name) {\n      if (this._events[name] != null) {\n        return this._events[name].length;\n      } else {\n        return 0;\n      }\n    }\n    trigger(name, ...args) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        var e, promises;\n        try {\n          if (name !== \"debug\") {\n            _this.trigger(\"debug\", `Event triggered: ${name}`, args);\n          }\n          if (_this._events[name] == null) {\n            return;\n          }\n          _this._events[name] = _this._events[name].filter(function (listener) {\n            return listener.status !== \"none\";\n          });\n          promises = _this._events[name].map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (listener) {\n              var e, returned;\n              if (listener.status === \"none\") {\n                return;\n              }\n              if (listener.status === \"once\") {\n                listener.status = \"none\";\n              }\n              try {\n                returned = typeof listener.cb === \"function\" ? listener.cb(...args) : void 0;\n                if (typeof (returned != null ? returned.then : void 0) === \"function\") {\n                  return yield returned;\n                } else {\n                  return returned;\n                }\n              } catch (error) {\n                e = error;\n                {\n                  _this.trigger(\"error\", e);\n                }\n                return null;\n              }\n            });\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n          return (yield Promise.all(promises)).find(function (x) {\n            return x != null;\n          });\n        } catch (error) {\n          e = error;\n          {\n            _this.trigger(\"error\", e);\n          }\n          return null;\n        }\n      })();\n    }\n  };\n  var Events_1 = Events;\n  var DLList$1, Events$1, Queues;\n  DLList$1 = DLList_1;\n  Events$1 = Events_1;\n  Queues = class Queues {\n    constructor(num_priorities) {\n      var i;\n      this.Events = new Events$1(this);\n      this._length = 0;\n      this._lists = function () {\n        var j, ref, results;\n        results = [];\n        for (i = j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n          results.push(new DLList$1(() => {\n            return this.incr();\n          }, () => {\n            return this.decr();\n          }));\n        }\n        return results;\n      }.call(this);\n    }\n    incr() {\n      if (this._length++ === 0) {\n        return this.Events.trigger(\"leftzero\");\n      }\n    }\n    decr() {\n      if (--this._length === 0) {\n        return this.Events.trigger(\"zero\");\n      }\n    }\n    push(job) {\n      return this._lists[job.options.priority].push(job);\n    }\n    queued(priority) {\n      if (priority != null) {\n        return this._lists[priority].length;\n      } else {\n        return this._length;\n      }\n    }\n    shiftAll(fn) {\n      return this._lists.forEach(function (list) {\n        return list.forEachShift(fn);\n      });\n    }\n    getFirst(arr = this._lists) {\n      var j, len, list;\n      for (j = 0, len = arr.length; j < len; j++) {\n        list = arr[j];\n        if (list.length > 0) {\n          return list;\n        }\n      }\n      return [];\n    }\n    shiftLastFrom(priority) {\n      return this.getFirst(this._lists.slice(priority).reverse()).shift();\n    }\n  };\n  var Queues_1 = Queues;\n  var BottleneckError;\n  BottleneckError = class BottleneckError extends Error {};\n  var BottleneckError_1 = BottleneckError;\n  var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;\n  NUM_PRIORITIES = 10;\n  DEFAULT_PRIORITY = 5;\n  parser$1 = parser;\n  BottleneckError$1 = BottleneckError_1;\n  Job = class Job {\n    constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise) {\n      this.task = task;\n      this.args = args;\n      this.rejectOnDrop = rejectOnDrop;\n      this.Events = Events;\n      this._states = _states;\n      this.Promise = Promise;\n      this.options = parser$1.load(options, jobDefaults);\n      this.options.priority = this._sanitizePriority(this.options.priority);\n      if (this.options.id === jobDefaults.id) {\n        this.options.id = `${this.options.id}-${this._randomIndex()}`;\n      }\n      this.promise = new this.Promise((_resolve, _reject) => {\n        this._resolve = _resolve;\n        this._reject = _reject;\n      });\n      this.retryCount = 0;\n    }\n    _sanitizePriority(priority) {\n      var sProperty;\n      sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;\n      if (sProperty < 0) {\n        return 0;\n      } else if (sProperty > NUM_PRIORITIES - 1) {\n        return NUM_PRIORITIES - 1;\n      } else {\n        return sProperty;\n      }\n    }\n    _randomIndex() {\n      return Math.random().toString(36).slice(2);\n    }\n    doDrop({\n      error,\n      message = \"This job has been dropped by Bottleneck\"\n    } = {}) {\n      if (this._states.remove(this.options.id)) {\n        if (this.rejectOnDrop) {\n          this._reject(error != null ? error : new BottleneckError$1(message));\n        }\n        this.Events.trigger(\"dropped\", {\n          args: this.args,\n          options: this.options,\n          task: this.task,\n          promise: this.promise\n        });\n        return true;\n      } else {\n        return false;\n      }\n    }\n    _assertStatus(expected) {\n      var status;\n      status = this._states.jobStatus(this.options.id);\n      if (!(status === expected || expected === \"DONE\" && status === null)) {\n        throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);\n      }\n    }\n    doReceive() {\n      this._states.start(this.options.id);\n      return this.Events.trigger(\"received\", {\n        args: this.args,\n        options: this.options\n      });\n    }\n    doQueue(reachedHWM, blocked) {\n      this._assertStatus(\"RECEIVED\");\n      this._states.next(this.options.id);\n      return this.Events.trigger(\"queued\", {\n        args: this.args,\n        options: this.options,\n        reachedHWM,\n        blocked\n      });\n    }\n    doRun() {\n      if (this.retryCount === 0) {\n        this._assertStatus(\"QUEUED\");\n        this._states.next(this.options.id);\n      } else {\n        this._assertStatus(\"EXECUTING\");\n      }\n      return this.Events.trigger(\"scheduled\", {\n        args: this.args,\n        options: this.options\n      });\n    }\n    doExecute(chained, clearGlobalState, run, free) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        var error, eventInfo, passed;\n        if (_this2.retryCount === 0) {\n          _this2._assertStatus(\"RUNNING\");\n          _this2._states.next(_this2.options.id);\n        } else {\n          _this2._assertStatus(\"EXECUTING\");\n        }\n        eventInfo = {\n          args: _this2.args,\n          options: _this2.options,\n          retryCount: _this2.retryCount\n        };\n        _this2.Events.trigger(\"executing\", eventInfo);\n        try {\n          passed = yield chained != null ? chained.schedule(_this2.options, _this2.task, ..._this2.args) : _this2.task(..._this2.args);\n          if (clearGlobalState()) {\n            _this2.doDone(eventInfo);\n            yield free(_this2.options, eventInfo);\n            _this2._assertStatus(\"DONE\");\n            return _this2._resolve(passed);\n          }\n        } catch (error1) {\n          error = error1;\n          return _this2._onFailure(error, eventInfo, clearGlobalState, run, free);\n        }\n      })();\n    }\n    doExpire(clearGlobalState, run, free) {\n      var error, eventInfo;\n      if (this._states.jobStatus(this.options.id === \"RUNNING\")) {\n        this._states.next(this.options.id);\n      }\n      this._assertStatus(\"EXECUTING\");\n      eventInfo = {\n        args: this.args,\n        options: this.options,\n        retryCount: this.retryCount\n      };\n      error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);\n      return this._onFailure(error, eventInfo, clearGlobalState, run, free);\n    }\n    _onFailure(error, eventInfo, clearGlobalState, run, free) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        var retry, retryAfter;\n        if (clearGlobalState()) {\n          retry = yield _this3.Events.trigger(\"failed\", error, eventInfo);\n          if (retry != null) {\n            retryAfter = ~~retry;\n            _this3.Events.trigger(\"retry\", `Retrying ${_this3.options.id} after ${retryAfter} ms`, eventInfo);\n            _this3.retryCount++;\n            return run(retryAfter);\n          } else {\n            _this3.doDone(eventInfo);\n            yield free(_this3.options, eventInfo);\n            _this3._assertStatus(\"DONE\");\n            return _this3._reject(error);\n          }\n        }\n      })();\n    }\n    doDone(eventInfo) {\n      this._assertStatus(\"EXECUTING\");\n      this._states.next(this.options.id);\n      return this.Events.trigger(\"done\", eventInfo);\n    }\n  };\n  var Job_1 = Job;\n  var BottleneckError$2, LocalDatastore, parser$2;\n  parser$2 = parser;\n  BottleneckError$2 = BottleneckError_1;\n  LocalDatastore = class LocalDatastore {\n    constructor(instance, storeOptions, storeInstanceOptions) {\n      this.instance = instance;\n      this.storeOptions = storeOptions;\n      this.clientId = this.instance._randomIndex();\n      parser$2.load(storeInstanceOptions, storeInstanceOptions, this);\n      this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\n      this._running = 0;\n      this._done = 0;\n      this._unblockTime = 0;\n      this.ready = this.Promise.resolve();\n      this.clients = {};\n      this._startHeartbeat();\n    }\n    _startHeartbeat() {\n      var base;\n      if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {\n        return typeof (base = this.heartbeat = setInterval(() => {\n          var amount, incr, maximum, now, reservoir;\n          now = Date.now();\n          if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {\n            this._lastReservoirRefresh = now;\n            this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;\n            this.instance._drainAll(this.computeCapacity());\n          }\n          if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {\n            ({\n              reservoirIncreaseAmount: amount,\n              reservoirIncreaseMaximum: maximum,\n              reservoir\n            } = this.storeOptions);\n            this._lastReservoirIncrease = now;\n            incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\n            if (incr > 0) {\n              this.storeOptions.reservoir += incr;\n              return this.instance._drainAll(this.computeCapacity());\n            }\n          }\n        }, this.heartbeatInterval)).unref === \"function\" ? base.unref() : void 0;\n      } else {\n        return clearInterval(this.heartbeat);\n      }\n    }\n    __publish__(message) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        yield _this4.yieldLoop();\n        return _this4.instance.Events.trigger(\"message\", message.toString());\n      })();\n    }\n    __disconnect__(flush) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        yield _this5.yieldLoop();\n        clearInterval(_this5.heartbeat);\n        return _this5.Promise.resolve();\n      })();\n    }\n    yieldLoop(t = 0) {\n      return new this.Promise(function (resolve, reject) {\n        return setTimeout(resolve, t);\n      });\n    }\n    computePenalty() {\n      var ref;\n      return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;\n    }\n    __updateSettings__(options) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        yield _this6.yieldLoop();\n        parser$2.overwrite(options, options, _this6.storeOptions);\n        _this6._startHeartbeat();\n        _this6.instance._drainAll(_this6.computeCapacity());\n        return true;\n      })();\n    }\n    __running__() {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        yield _this7.yieldLoop();\n        return _this7._running;\n      })();\n    }\n    __queued__() {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        yield _this8.yieldLoop();\n        return _this8.instance.queued();\n      })();\n    }\n    __done__() {\n      var _this9 = this;\n      return _asyncToGenerator(function* () {\n        yield _this9.yieldLoop();\n        return _this9._done;\n      })();\n    }\n    __groupCheck__(time) {\n      var _this10 = this;\n      return _asyncToGenerator(function* () {\n        yield _this10.yieldLoop();\n        return _this10._nextRequest + _this10.timeout < time;\n      })();\n    }\n    computeCapacity() {\n      var maxConcurrent, reservoir;\n      ({\n        maxConcurrent,\n        reservoir\n      } = this.storeOptions);\n      if (maxConcurrent != null && reservoir != null) {\n        return Math.min(maxConcurrent - this._running, reservoir);\n      } else if (maxConcurrent != null) {\n        return maxConcurrent - this._running;\n      } else if (reservoir != null) {\n        return reservoir;\n      } else {\n        return null;\n      }\n    }\n    conditionsCheck(weight) {\n      var capacity;\n      capacity = this.computeCapacity();\n      return capacity == null || weight <= capacity;\n    }\n    __incrementReservoir__(incr) {\n      var _this11 = this;\n      return _asyncToGenerator(function* () {\n        var reservoir;\n        yield _this11.yieldLoop();\n        reservoir = _this11.storeOptions.reservoir += incr;\n        _this11.instance._drainAll(_this11.computeCapacity());\n        return reservoir;\n      })();\n    }\n    __currentReservoir__() {\n      var _this12 = this;\n      return _asyncToGenerator(function* () {\n        yield _this12.yieldLoop();\n        return _this12.storeOptions.reservoir;\n      })();\n    }\n    isBlocked(now) {\n      return this._unblockTime >= now;\n    }\n    check(weight, now) {\n      return this.conditionsCheck(weight) && this._nextRequest - now <= 0;\n    }\n    __check__(weight) {\n      var _this13 = this;\n      return _asyncToGenerator(function* () {\n        var now;\n        yield _this13.yieldLoop();\n        now = Date.now();\n        return _this13.check(weight, now);\n      })();\n    }\n    __register__(index, weight, expiration) {\n      var _this14 = this;\n      return _asyncToGenerator(function* () {\n        var now, wait;\n        yield _this14.yieldLoop();\n        now = Date.now();\n        if (_this14.conditionsCheck(weight)) {\n          _this14._running += weight;\n          if (_this14.storeOptions.reservoir != null) {\n            _this14.storeOptions.reservoir -= weight;\n          }\n          wait = Math.max(_this14._nextRequest - now, 0);\n          _this14._nextRequest = now + wait + _this14.storeOptions.minTime;\n          return {\n            success: true,\n            wait,\n            reservoir: _this14.storeOptions.reservoir\n          };\n        } else {\n          return {\n            success: false\n          };\n        }\n      })();\n    }\n    strategyIsBlock() {\n      return this.storeOptions.strategy === 3;\n    }\n    __submit__(queueLength, weight) {\n      var _this15 = this;\n      return _asyncToGenerator(function* () {\n        var blocked, now, reachedHWM;\n        yield _this15.yieldLoop();\n        if (_this15.storeOptions.maxConcurrent != null && weight > _this15.storeOptions.maxConcurrent) {\n          throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this15.storeOptions.maxConcurrent}`);\n        }\n        now = Date.now();\n        reachedHWM = _this15.storeOptions.highWater != null && queueLength === _this15.storeOptions.highWater && !_this15.check(weight, now);\n        blocked = _this15.strategyIsBlock() && (reachedHWM || _this15.isBlocked(now));\n        if (blocked) {\n          _this15._unblockTime = now + _this15.computePenalty();\n          _this15._nextRequest = _this15._unblockTime + _this15.storeOptions.minTime;\n          _this15.instance._dropAllQueued();\n        }\n        return {\n          reachedHWM,\n          blocked,\n          strategy: _this15.storeOptions.strategy\n        };\n      })();\n    }\n    __free__(index, weight) {\n      var _this16 = this;\n      return _asyncToGenerator(function* () {\n        yield _this16.yieldLoop();\n        _this16._running -= weight;\n        _this16._done += weight;\n        _this16.instance._drainAll(_this16.computeCapacity());\n        return {\n          running: _this16._running\n        };\n      })();\n    }\n  };\n  var LocalDatastore_1 = LocalDatastore;\n  var BottleneckError$3, States;\n  BottleneckError$3 = BottleneckError_1;\n  States = class States {\n    constructor(status1) {\n      this.status = status1;\n      this._jobs = {};\n      this.counts = this.status.map(function () {\n        return 0;\n      });\n    }\n    next(id) {\n      var current, next;\n      current = this._jobs[id];\n      next = current + 1;\n      if (current != null && next < this.status.length) {\n        this.counts[current]--;\n        this.counts[next]++;\n        return this._jobs[id]++;\n      } else if (current != null) {\n        this.counts[current]--;\n        return delete this._jobs[id];\n      }\n    }\n    start(id) {\n      var initial;\n      initial = 0;\n      this._jobs[id] = initial;\n      return this.counts[initial]++;\n    }\n    remove(id) {\n      var current;\n      current = this._jobs[id];\n      if (current != null) {\n        this.counts[current]--;\n        delete this._jobs[id];\n      }\n      return current != null;\n    }\n    jobStatus(id) {\n      var ref;\n      return (ref = this.status[this._jobs[id]]) != null ? ref : null;\n    }\n    statusJobs(status) {\n      var k, pos, ref, results, v;\n      if (status != null) {\n        pos = this.status.indexOf(status);\n        if (pos < 0) {\n          throw new BottleneckError$3(`status must be one of ${this.status.join(', ')}`);\n        }\n        ref = this._jobs;\n        results = [];\n        for (k in ref) {\n          v = ref[k];\n          if (v === pos) {\n            results.push(k);\n          }\n        }\n        return results;\n      } else {\n        return Object.keys(this._jobs);\n      }\n    }\n    statusCounts() {\n      return this.counts.reduce((acc, v, i) => {\n        acc[this.status[i]] = v;\n        return acc;\n      }, {});\n    }\n  };\n  var States_1 = States;\n  var DLList$2, Sync;\n  DLList$2 = DLList_1;\n  Sync = class Sync {\n    constructor(name, Promise) {\n      this.schedule = this.schedule.bind(this);\n      this.name = name;\n      this.Promise = Promise;\n      this._running = 0;\n      this._queue = new DLList$2();\n    }\n    isEmpty() {\n      return this._queue.length === 0;\n    }\n    _tryToRun() {\n      var _this17 = this;\n      return _asyncToGenerator(function* () {\n        var args, cb, error, reject, resolve, returned, task;\n        if (_this17._running < 1 && _this17._queue.length > 0) {\n          _this17._running++;\n          ({\n            task,\n            args,\n            resolve,\n            reject\n          } = _this17._queue.shift());\n          cb = yield _asyncToGenerator(function* () {\n            try {\n              returned = yield task(...args);\n              return function () {\n                return resolve(returned);\n              };\n            } catch (error1) {\n              error = error1;\n              return function () {\n                return reject(error);\n              };\n            }\n          })();\n          _this17._running--;\n          _this17._tryToRun();\n          return cb();\n        }\n      })();\n    }\n    schedule(task, ...args) {\n      var promise, reject, resolve;\n      resolve = reject = null;\n      promise = new this.Promise(function (_resolve, _reject) {\n        resolve = _resolve;\n        return reject = _reject;\n      });\n      this._queue.push({\n        task,\n        args,\n        resolve,\n        reject\n      });\n      this._tryToRun();\n      return promise;\n    }\n  };\n  var Sync_1 = Sync;\n  var version = \"2.19.5\";\n  var version$1 = {\n    version: version\n  };\n  var version$2 = /*#__PURE__*/Object.freeze({\n    version: version,\n    default: version$1\n  });\n  var require$$2 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n  var require$$3 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n  var require$$4 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n  var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;\n  parser$3 = parser;\n  Events$2 = Events_1;\n  RedisConnection$1 = require$$2;\n  IORedisConnection$1 = require$$3;\n  Scripts$1 = require$$4;\n  Group = function () {\n    class Group {\n      constructor(limiterOptions = {}) {\n        this.deleteKey = this.deleteKey.bind(this);\n        this.limiterOptions = limiterOptions;\n        parser$3.load(this.limiterOptions, this.defaults, this);\n        this.Events = new Events$2(this);\n        this.instances = {};\n        this.Bottleneck = Bottleneck_1;\n        this._startAutoCleanup();\n        this.sharedConnection = this.connection != null;\n        if (this.connection == null) {\n          if (this.limiterOptions.datastore === \"redis\") {\n            this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, {\n              Events: this.Events\n            }));\n          } else if (this.limiterOptions.datastore === \"ioredis\") {\n            this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, {\n              Events: this.Events\n            }));\n          }\n        }\n      }\n      key(key = \"\") {\n        var ref;\n        return (ref = this.instances[key]) != null ? ref : (() => {\n          var limiter;\n          limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {\n            id: `${this.id}-${key}`,\n            timeout: this.timeout,\n            connection: this.connection\n          }));\n          this.Events.trigger(\"created\", limiter, key);\n          return limiter;\n        })();\n      }\n      deleteKey(key = \"\") {\n        var _this18 = this;\n        return _asyncToGenerator(function* () {\n          var deleted, instance;\n          instance = _this18.instances[key];\n          if (_this18.connection) {\n            deleted = yield _this18.connection.__runCommand__(['del', ...Scripts$1.allKeys(`${_this18.id}-${key}`)]);\n          }\n          if (instance != null) {\n            delete _this18.instances[key];\n            yield instance.disconnect();\n          }\n          return instance != null || deleted > 0;\n        })();\n      }\n      limiters() {\n        var k, ref, results, v;\n        ref = this.instances;\n        results = [];\n        for (k in ref) {\n          v = ref[k];\n          results.push({\n            key: k,\n            limiter: v\n          });\n        }\n        return results;\n      }\n      keys() {\n        return Object.keys(this.instances);\n      }\n      clusterKeys() {\n        var _this19 = this;\n        return _asyncToGenerator(function* () {\n          var cursor, end, found, i, k, keys, len, next, start;\n          if (_this19.connection == null) {\n            return _this19.Promise.resolve(_this19.keys());\n          }\n          keys = [];\n          cursor = null;\n          start = `b_${_this19.id}-`.length;\n          end = \"_settings\".length;\n          while (cursor !== 0) {\n            [next, found] = yield _this19.connection.__runCommand__([\"scan\", cursor != null ? cursor : 0, \"match\", `b_${_this19.id}-*_settings`, \"count\", 10000]);\n            cursor = ~~next;\n            for (i = 0, len = found.length; i < len; i++) {\n              k = found[i];\n              keys.push(k.slice(start, -end));\n            }\n          }\n          return keys;\n        })();\n      }\n      _startAutoCleanup() {\n        var _this20 = this;\n        var base;\n        clearInterval(this.interval);\n        return typeof (base = this.interval = setInterval( /*#__PURE__*/_asyncToGenerator(function* () {\n          var e, k, ref, results, time, v;\n          time = Date.now();\n          ref = _this20.instances;\n          results = [];\n          for (k in ref) {\n            v = ref[k];\n            try {\n              if (yield v._store.__groupCheck__(time)) {\n                results.push(_this20.deleteKey(k));\n              } else {\n                results.push(void 0);\n              }\n            } catch (error) {\n              e = error;\n              results.push(v.Events.trigger(\"error\", e));\n            }\n          }\n          return results;\n        }), this.timeout / 2)).unref === \"function\" ? base.unref() : void 0;\n      }\n      updateSettings(options = {}) {\n        parser$3.overwrite(options, this.defaults, this);\n        parser$3.overwrite(options, options, this.limiterOptions);\n        if (options.timeout != null) {\n          return this._startAutoCleanup();\n        }\n      }\n      disconnect(flush = true) {\n        var ref;\n        if (!this.sharedConnection) {\n          return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;\n        }\n      }\n    }\n    Group.prototype.defaults = {\n      timeout: 1000 * 60 * 5,\n      connection: null,\n      Promise: Promise,\n      id: \"group-key\"\n    };\n    return Group;\n  }.call(commonjsGlobal);\n  var Group_1 = Group;\n  var Batcher, Events$3, parser$4;\n  parser$4 = parser;\n  Events$3 = Events_1;\n  Batcher = function () {\n    class Batcher {\n      constructor(options = {}) {\n        this.options = options;\n        parser$4.load(this.options, this.defaults, this);\n        this.Events = new Events$3(this);\n        this._arr = [];\n        this._resetPromise();\n        this._lastFlush = Date.now();\n      }\n      _resetPromise() {\n        return this._promise = new this.Promise((res, rej) => {\n          return this._resolve = res;\n        });\n      }\n      _flush() {\n        clearTimeout(this._timeout);\n        this._lastFlush = Date.now();\n        this._resolve();\n        this.Events.trigger(\"batch\", this._arr);\n        this._arr = [];\n        return this._resetPromise();\n      }\n      add(data) {\n        var ret;\n        this._arr.push(data);\n        ret = this._promise;\n        if (this._arr.length === this.maxSize) {\n          this._flush();\n        } else if (this.maxTime != null && this._arr.length === 1) {\n          this._timeout = setTimeout(() => {\n            return this._flush();\n          }, this.maxTime);\n        }\n        return ret;\n      }\n    }\n    Batcher.prototype.defaults = {\n      maxTime: null,\n      maxSize: null,\n      Promise: Promise\n    };\n    return Batcher;\n  }.call(commonjsGlobal);\n  var Batcher_1 = Batcher;\n  var require$$4$1 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n  var require$$8 = getCjsExportFromNamespace(version$2);\n  var Bottleneck,\n    DEFAULT_PRIORITY$1,\n    Events$4,\n    Job$1,\n    LocalDatastore$1,\n    NUM_PRIORITIES$1,\n    Queues$1,\n    RedisDatastore$1,\n    States$1,\n    Sync$1,\n    parser$5,\n    splice = [].splice;\n  NUM_PRIORITIES$1 = 10;\n  DEFAULT_PRIORITY$1 = 5;\n  parser$5 = parser;\n  Queues$1 = Queues_1;\n  Job$1 = Job_1;\n  LocalDatastore$1 = LocalDatastore_1;\n  RedisDatastore$1 = require$$4$1;\n  Events$4 = Events_1;\n  States$1 = States_1;\n  Sync$1 = Sync_1;\n  Bottleneck = function () {\n    class Bottleneck {\n      constructor(options = {}, ...invalid) {\n        var storeInstanceOptions, storeOptions;\n        this._addToQueue = this._addToQueue.bind(this);\n        this._validateOptions(options, invalid);\n        parser$5.load(options, this.instanceDefaults, this);\n        this._queues = new Queues$1(NUM_PRIORITIES$1);\n        this._scheduled = {};\n        this._states = new States$1([\"RECEIVED\", \"QUEUED\", \"RUNNING\", \"EXECUTING\"].concat(this.trackDoneStatus ? [\"DONE\"] : []));\n        this._limiter = null;\n        this.Events = new Events$4(this);\n        this._submitLock = new Sync$1(\"submit\", this.Promise);\n        this._registerLock = new Sync$1(\"register\", this.Promise);\n        storeOptions = parser$5.load(options, this.storeDefaults, {});\n        this._store = function () {\n          if (this.datastore === \"redis\" || this.datastore === \"ioredis\" || this.connection != null) {\n            storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});\n            return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);\n          } else if (this.datastore === \"local\") {\n            storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});\n            return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);\n          } else {\n            throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);\n          }\n        }.call(this);\n        this._queues.on(\"leftzero\", () => {\n          var ref;\n          return (ref = this._store.heartbeat) != null ? typeof ref.ref === \"function\" ? ref.ref() : void 0 : void 0;\n        });\n        this._queues.on(\"zero\", () => {\n          var ref;\n          return (ref = this._store.heartbeat) != null ? typeof ref.unref === \"function\" ? ref.unref() : void 0 : void 0;\n        });\n      }\n      _validateOptions(options, invalid) {\n        if (!(options != null && typeof options === \"object\" && invalid.length === 0)) {\n          throw new Bottleneck.prototype.BottleneckError(\"Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.\");\n        }\n      }\n      ready() {\n        return this._store.ready;\n      }\n      clients() {\n        return this._store.clients;\n      }\n      channel() {\n        return `b_${this.id}`;\n      }\n      channel_client() {\n        return `b_${this.id}_${this._store.clientId}`;\n      }\n      publish(message) {\n        return this._store.__publish__(message);\n      }\n      disconnect(flush = true) {\n        return this._store.__disconnect__(flush);\n      }\n      chain(_limiter) {\n        this._limiter = _limiter;\n        return this;\n      }\n      queued(priority) {\n        return this._queues.queued(priority);\n      }\n      clusterQueued() {\n        return this._store.__queued__();\n      }\n      empty() {\n        return this.queued() === 0 && this._submitLock.isEmpty();\n      }\n      running() {\n        return this._store.__running__();\n      }\n      done() {\n        return this._store.__done__();\n      }\n      jobStatus(id) {\n        return this._states.jobStatus(id);\n      }\n      jobs(status) {\n        return this._states.statusJobs(status);\n      }\n      counts() {\n        return this._states.statusCounts();\n      }\n      _randomIndex() {\n        return Math.random().toString(36).slice(2);\n      }\n      check(weight = 1) {\n        return this._store.__check__(weight);\n      }\n      _clearGlobalState(index) {\n        if (this._scheduled[index] != null) {\n          clearTimeout(this._scheduled[index].expiration);\n          delete this._scheduled[index];\n          return true;\n        } else {\n          return false;\n        }\n      }\n      _free(index, job, options, eventInfo) {\n        var _this21 = this;\n        return _asyncToGenerator(function* () {\n          var e, running;\n          try {\n            ({\n              running\n            } = yield _this21._store.__free__(index, options.weight));\n            _this21.Events.trigger(\"debug\", `Freed ${options.id}`, eventInfo);\n            if (running === 0 && _this21.empty()) {\n              return _this21.Events.trigger(\"idle\");\n            }\n          } catch (error1) {\n            e = error1;\n            return _this21.Events.trigger(\"error\", e);\n          }\n        })();\n      }\n      _run(index, job, wait) {\n        var clearGlobalState, free, run;\n        job.doRun();\n        clearGlobalState = this._clearGlobalState.bind(this, index);\n        run = this._run.bind(this, index, job);\n        free = this._free.bind(this, index, job);\n        return this._scheduled[index] = {\n          timeout: setTimeout(() => {\n            return job.doExecute(this._limiter, clearGlobalState, run, free);\n          }, wait),\n          expiration: job.options.expiration != null ? setTimeout(function () {\n            return job.doExpire(clearGlobalState, run, free);\n          }, wait + job.options.expiration) : void 0,\n          job: job\n        };\n      }\n      _drainOne(capacity) {\n        return this._registerLock.schedule(() => {\n          var args, index, next, options, queue;\n          if (this.queued() === 0) {\n            return this.Promise.resolve(null);\n          }\n          queue = this._queues.getFirst();\n          ({\n            options,\n            args\n          } = next = queue.first());\n          if (capacity != null && options.weight > capacity) {\n            return this.Promise.resolve(null);\n          }\n          this.Events.trigger(\"debug\", `Draining ${options.id}`, {\n            args,\n            options\n          });\n          index = this._randomIndex();\n          return this._store.__register__(index, options.weight, options.expiration).then(({\n            success,\n            wait,\n            reservoir\n          }) => {\n            var empty;\n            this.Events.trigger(\"debug\", `Drained ${options.id}`, {\n              success,\n              args,\n              options\n            });\n            if (success) {\n              queue.shift();\n              empty = this.empty();\n              if (empty) {\n                this.Events.trigger(\"empty\");\n              }\n              if (reservoir === 0) {\n                this.Events.trigger(\"depleted\", empty);\n              }\n              this._run(index, next, wait);\n              return this.Promise.resolve(options.weight);\n            } else {\n              return this.Promise.resolve(null);\n            }\n          });\n        });\n      }\n      _drainAll(capacity, total = 0) {\n        return this._drainOne(capacity).then(drained => {\n          var newCapacity;\n          if (drained != null) {\n            newCapacity = capacity != null ? capacity - drained : capacity;\n            return this._drainAll(newCapacity, total + drained);\n          } else {\n            return this.Promise.resolve(total);\n          }\n        }).catch(e => {\n          return this.Events.trigger(\"error\", e);\n        });\n      }\n      _dropAllQueued(message) {\n        return this._queues.shiftAll(function (job) {\n          return job.doDrop({\n            message\n          });\n        });\n      }\n      stop(options = {}) {\n        var done, waitForExecuting;\n        options = parser$5.load(options, this.stopDefaults);\n        waitForExecuting = at => {\n          var finished;\n          finished = () => {\n            var counts;\n            counts = this._states.counts;\n            return counts[0] + counts[1] + counts[2] + counts[3] === at;\n          };\n          return new this.Promise((resolve, reject) => {\n            if (finished()) {\n              return resolve();\n            } else {\n              return this.on(\"done\", () => {\n                if (finished()) {\n                  this.removeAllListeners(\"done\");\n                  return resolve();\n                }\n              });\n            }\n          });\n        };\n        done = options.dropWaitingJobs ? (this._run = function (index, next) {\n          return next.doDrop({\n            message: options.dropErrorMessage\n          });\n        }, this._drainOne = () => {\n          return this.Promise.resolve(null);\n        }, this._registerLock.schedule(() => {\n          return this._submitLock.schedule(() => {\n            var k, ref, v;\n            ref = this._scheduled;\n            for (k in ref) {\n              v = ref[k];\n              if (this.jobStatus(v.job.options.id) === \"RUNNING\") {\n                clearTimeout(v.timeout);\n                clearTimeout(v.expiration);\n                v.job.doDrop({\n                  message: options.dropErrorMessage\n                });\n              }\n            }\n            this._dropAllQueued(options.dropErrorMessage);\n            return waitForExecuting(0);\n          });\n        })) : this.schedule({\n          priority: NUM_PRIORITIES$1 - 1,\n          weight: 0\n        }, () => {\n          return waitForExecuting(1);\n        });\n        this._receive = function (job) {\n          return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));\n        };\n        this.stop = () => {\n          return this.Promise.reject(new Bottleneck.prototype.BottleneckError(\"stop() has already been called\"));\n        };\n        return done;\n      }\n      _addToQueue(job) {\n        var _this22 = this;\n        return _asyncToGenerator(function* () {\n          var args, blocked, error, options, reachedHWM, shifted, strategy;\n          ({\n            args,\n            options\n          } = job);\n          try {\n            ({\n              reachedHWM,\n              blocked,\n              strategy\n            } = yield _this22._store.__submit__(_this22.queued(), options.weight));\n          } catch (error1) {\n            error = error1;\n            _this22.Events.trigger(\"debug\", `Could not queue ${options.id}`, {\n              args,\n              options,\n              error\n            });\n            job.doDrop({\n              error\n            });\n            return false;\n          }\n          if (blocked) {\n            job.doDrop();\n            return true;\n          } else if (reachedHWM) {\n            shifted = strategy === Bottleneck.prototype.strategy.LEAK ? _this22._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? _this22._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;\n            if (shifted != null) {\n              shifted.doDrop();\n            }\n            if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {\n              if (shifted == null) {\n                job.doDrop();\n              }\n              return reachedHWM;\n            }\n          }\n          job.doQueue(reachedHWM, blocked);\n          _this22._queues.push(job);\n          yield _this22._drainAll();\n          return reachedHWM;\n        })();\n      }\n      _receive(job) {\n        if (this._states.jobStatus(job.options.id) != null) {\n          job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));\n          return false;\n        } else {\n          job.doReceive();\n          return this._submitLock.schedule(this._addToQueue, job);\n        }\n      }\n      submit(...args) {\n        var cb, fn, job, options, ref, ref1, task;\n        if (typeof args[0] === \"function\") {\n          ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);\n          options = parser$5.load({}, this.jobDefaults);\n        } else {\n          ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);\n          options = parser$5.load(options, this.jobDefaults);\n        }\n        task = (...args) => {\n          return new this.Promise(function (resolve, reject) {\n            return fn(...args, function (...args) {\n              return (args[0] != null ? reject : resolve)(args);\n            });\n          });\n        };\n        job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n        job.promise.then(function (args) {\n          return typeof cb === \"function\" ? cb(...args) : void 0;\n        }).catch(function (args) {\n          if (Array.isArray(args)) {\n            return typeof cb === \"function\" ? cb(...args) : void 0;\n          } else {\n            return typeof cb === \"function\" ? cb(args) : void 0;\n          }\n        });\n        return this._receive(job);\n      }\n      schedule(...args) {\n        var job, options, task;\n        if (typeof args[0] === \"function\") {\n          [task, ...args] = args;\n          options = {};\n        } else {\n          [options, task, ...args] = args;\n        }\n        job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n        this._receive(job);\n        return job.promise;\n      }\n      wrap(fn) {\n        var schedule, wrapped;\n        schedule = this.schedule.bind(this);\n        wrapped = function (...args) {\n          return schedule(fn.bind(this), ...args);\n        };\n        wrapped.withOptions = function (options, ...args) {\n          return schedule(options, fn, ...args);\n        };\n        return wrapped;\n      }\n      updateSettings(options = {}) {\n        var _this23 = this;\n        return _asyncToGenerator(function* () {\n          yield _this23._store.__updateSettings__(parser$5.overwrite(options, _this23.storeDefaults));\n          parser$5.overwrite(options, _this23.instanceDefaults, _this23);\n          return _this23;\n        })();\n      }\n      currentReservoir() {\n        return this._store.__currentReservoir__();\n      }\n      incrementReservoir(incr = 0) {\n        return this._store.__incrementReservoir__(incr);\n      }\n    }\n    Bottleneck.default = Bottleneck;\n    Bottleneck.Events = Events$4;\n    Bottleneck.version = Bottleneck.prototype.version = require$$8.version;\n    Bottleneck.strategy = Bottleneck.prototype.strategy = {\n      LEAK: 1,\n      OVERFLOW: 2,\n      OVERFLOW_PRIORITY: 4,\n      BLOCK: 3\n    };\n    Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = BottleneckError_1;\n    Bottleneck.Group = Bottleneck.prototype.Group = Group_1;\n    Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = require$$2;\n    Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = require$$3;\n    Bottleneck.Batcher = Bottleneck.prototype.Batcher = Batcher_1;\n    Bottleneck.prototype.jobDefaults = {\n      priority: DEFAULT_PRIORITY$1,\n      weight: 1,\n      expiration: null,\n      id: \"<no-id>\"\n    };\n    Bottleneck.prototype.storeDefaults = {\n      maxConcurrent: null,\n      minTime: 0,\n      highWater: null,\n      strategy: Bottleneck.prototype.strategy.LEAK,\n      penalty: null,\n      reservoir: null,\n      reservoirRefreshInterval: null,\n      reservoirRefreshAmount: null,\n      reservoirIncreaseInterval: null,\n      reservoirIncreaseAmount: null,\n      reservoirIncreaseMaximum: null\n    };\n    Bottleneck.prototype.localStoreDefaults = {\n      Promise: Promise,\n      timeout: null,\n      heartbeatInterval: 250\n    };\n    Bottleneck.prototype.redisStoreDefaults = {\n      Promise: Promise,\n      timeout: null,\n      heartbeatInterval: 5000,\n      clientTimeout: 10000,\n      Redis: null,\n      clientOptions: {},\n      clusterNodes: null,\n      clearDatastore: false,\n      connection: null\n    };\n    Bottleneck.prototype.instanceDefaults = {\n      datastore: \"local\",\n      connection: null,\n      id: \"<no-id>\",\n      rejectOnDrop: true,\n      trackDoneStatus: false,\n      Promise: Promise\n    };\n    Bottleneck.prototype.stopDefaults = {\n      enqueueErrorMessage: \"This limiter has been stopped and cannot accept new jobs.\",\n      dropWaitingJobs: true,\n      dropErrorMessage: \"This limiter has been stopped.\"\n    };\n    return Bottleneck;\n  }.call(commonjsGlobal);\n  var Bottleneck_1 = Bottleneck;\n  var lib = Bottleneck_1;\n  return lib;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}