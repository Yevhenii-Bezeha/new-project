{"ast":null,"code":"import _asyncToGenerator from \"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// pkg/dist-src/index.js\nimport BottleneckLight from \"bottleneck/light\";\nimport { Octokit } from \"@octokit/core\";\n\n// pkg/dist-src/version.js\nvar VERSION = \"7.0.0\";\n\n// pkg/dist-src/wrap-request.js\nvar noop = () => Promise.resolve();\nfunction wrapRequest(state, request, options) {\n  return state.retryLimiter.schedule(doRequest, state, request, options);\n}\nfunction doRequest(_x, _x2, _x3) {\n  return _doRequest.apply(this, arguments);\n} // pkg/dist-src/generated/triggers-notification-paths.js\nfunction _doRequest() {\n  _doRequest = _asyncToGenerator(function* (state, request, options) {\n    const isWrite = options.method !== \"GET\" && options.method !== \"HEAD\";\n    const {\n      pathname\n    } = new URL(options.url, \"http://github.test\");\n    const isSearch = options.method === \"GET\" && pathname.startsWith(\"/search/\");\n    const isGraphQL = pathname.startsWith(\"/graphql\");\n    const retryCount = ~~request.retryCount;\n    const jobOptions = retryCount > 0 ? {\n      priority: 0,\n      weight: 0\n    } : {};\n    if (state.clustering) {\n      jobOptions.expiration = 1e3 * 60;\n    }\n    if (isWrite || isGraphQL) {\n      yield state.write.key(state.id).schedule(jobOptions, noop);\n    }\n    if (isWrite && state.triggersNotification(pathname)) {\n      yield state.notifications.key(state.id).schedule(jobOptions, noop);\n    }\n    if (isSearch) {\n      yield state.search.key(state.id).schedule(jobOptions, noop);\n    }\n    const req = state.global.key(state.id).schedule(jobOptions, request, options);\n    if (isGraphQL) {\n      const res = yield req;\n      if (res.data.errors != null &&\n      // @ts-expect-error\n      res.data.errors.some(error => error.type === \"RATE_LIMITED\")) {\n        const error = Object.assign(new Error(\"GraphQL Rate Limit Exceeded\"), {\n          response: res,\n          data: res.data\n        });\n        throw error;\n      }\n    }\n    return req;\n  });\n  return _doRequest.apply(this, arguments);\n}\nvar triggers_notification_paths_default = [\"/orgs/{org}/invitations\", \"/orgs/{org}/invitations/{invitation_id}\", \"/orgs/{org}/teams/{team_slug}/discussions\", \"/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\", \"/repos/{owner}/{repo}/collaborators/{username}\", \"/repos/{owner}/{repo}/commits/{commit_sha}/comments\", \"/repos/{owner}/{repo}/issues\", \"/repos/{owner}/{repo}/issues/{issue_number}/comments\", \"/repos/{owner}/{repo}/pulls\", \"/repos/{owner}/{repo}/pulls/{pull_number}/comments\", \"/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies\", \"/repos/{owner}/{repo}/pulls/{pull_number}/merge\", \"/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\", \"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\", \"/repos/{owner}/{repo}/releases\", \"/teams/{team_id}/discussions\", \"/teams/{team_id}/discussions/{discussion_number}/comments\"];\n\n// pkg/dist-src/route-matcher.js\nfunction routeMatcher(paths) {\n  const regexes = paths.map(path => path.split(\"/\").map(c => c.startsWith(\"{\") ? \"(?:.+?)\" : c).join(\"/\"));\n  const regex2 = `^(?:${regexes.map(r => `(?:${r})`).join(\"|\")})[^/]*$`;\n  return new RegExp(regex2, \"i\");\n}\n\n// pkg/dist-src/index.js\nvar regex = routeMatcher(triggers_notification_paths_default);\nvar triggersNotification = regex.test.bind(regex);\nvar groups = {};\nvar createGroups = function (Bottleneck, common) {\n  groups.global = new Bottleneck.Group({\n    id: \"octokit-global\",\n    maxConcurrent: 10,\n    ...common\n  });\n  groups.search = new Bottleneck.Group({\n    id: \"octokit-search\",\n    maxConcurrent: 1,\n    minTime: 2e3,\n    ...common\n  });\n  groups.write = new Bottleneck.Group({\n    id: \"octokit-write\",\n    maxConcurrent: 1,\n    minTime: 1e3,\n    ...common\n  });\n  groups.notifications = new Bottleneck.Group({\n    id: \"octokit-notifications\",\n    maxConcurrent: 1,\n    minTime: 3e3,\n    ...common\n  });\n};\nfunction throttling(octokit, octokitOptions) {\n  const {\n    enabled = true,\n    Bottleneck = BottleneckLight,\n    id = \"no-id\",\n    timeout = 1e3 * 60 * 2,\n    // Redis TTL: 2 minutes\n    connection\n  } = octokitOptions.throttle || {};\n  if (!enabled) {\n    return {};\n  }\n  const common = {\n    connection,\n    timeout\n  };\n  if (groups.global == null) {\n    createGroups(Bottleneck, common);\n  }\n  const state = Object.assign({\n    clustering: connection != null,\n    triggersNotification,\n    fallbackSecondaryRateRetryAfter: 60,\n    retryAfterBaseValue: 1e3,\n    retryLimiter: new Bottleneck(),\n    id,\n    ...groups\n  }, octokitOptions.throttle);\n  if (typeof state.onSecondaryRateLimit !== \"function\" || typeof state.onRateLimit !== \"function\") {\n    throw new Error(`octokit/plugin-throttling error:\n        You must pass the onSecondaryRateLimit and onRateLimit error handlers.\n        See https://octokit.github.io/rest.js/#throttling\n\n        const octokit = new Octokit({\n          throttle: {\n            onSecondaryRateLimit: (retryAfter, options) => {/* ... */},\n            onRateLimit: (retryAfter, options) => {/* ... */}\n          }\n        })\n    `);\n  }\n  const events = {};\n  const emitter = new Bottleneck.Events(events);\n  events.on(\"secondary-limit\", state.onSecondaryRateLimit);\n  events.on(\"rate-limit\", state.onRateLimit);\n  events.on(\"error\", e => octokit.log.warn(\"Error in throttling-plugin limit handler\", e));\n  state.retryLimiter.on(\"failed\", /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (error, info) {\n      const [state2, request, options] = info.args;\n      const {\n        pathname\n      } = new URL(options.url, \"http://github.test\");\n      const shouldRetryGraphQL = pathname.startsWith(\"/graphql\") && error.status !== 401;\n      if (!(shouldRetryGraphQL || error.status === 403)) {\n        return;\n      }\n      const retryCount = ~~request.retryCount;\n      request.retryCount = retryCount;\n      options.request.retryCount = retryCount;\n      const {\n        wantRetry,\n        retryAfter = 0\n      } = yield _asyncToGenerator(function* () {\n        if (/\\bsecondary rate\\b/i.test(error.message)) {\n          const retryAfter2 = Number(error.response.headers[\"retry-after\"]) || state2.fallbackSecondaryRateRetryAfter;\n          const wantRetry2 = yield emitter.trigger(\"secondary-limit\", retryAfter2, options, octokit, retryCount);\n          return {\n            wantRetry: wantRetry2,\n            retryAfter: retryAfter2\n          };\n        }\n        if (error.response.headers != null && error.response.headers[\"x-ratelimit-remaining\"] === \"0\") {\n          const rateLimitReset = new Date(~~error.response.headers[\"x-ratelimit-reset\"] * 1e3).getTime();\n          const retryAfter2 = Math.max(Math.ceil((rateLimitReset - Date.now()) / 1e3), 0);\n          const wantRetry2 = yield emitter.trigger(\"rate-limit\", retryAfter2, options, octokit, retryCount);\n          return {\n            wantRetry: wantRetry2,\n            retryAfter: retryAfter2\n          };\n        }\n        return {};\n      })();\n      if (wantRetry) {\n        request.retryCount++;\n        return retryAfter * state2.retryAfterBaseValue;\n      }\n    });\n    return function (_x4, _x5) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  octokit.hook.wrap(\"request\", wrapRequest.bind(null, state));\n  return {};\n}\nthrottling.VERSION = VERSION;\nthrottling.triggersNotification = triggersNotification;\nexport { throttling };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}