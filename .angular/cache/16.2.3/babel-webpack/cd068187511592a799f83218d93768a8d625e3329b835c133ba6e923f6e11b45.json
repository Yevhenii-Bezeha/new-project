{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// pkg/dist-src/index.js\nvar dist_src_exports = {};\n__export(dist_src_exports, {\n  createAppAuth: () => createAppAuth,\n  createOAuthUserAuth: () => import_auth_oauth_user2.createOAuthUserAuth\n});\nmodule.exports = __toCommonJS(dist_src_exports);\nvar import_universal_user_agent = require(\"universal-user-agent\");\nvar import_request = require(\"@octokit/request\");\nvar import_auth_oauth_app = require(\"@octokit/auth-oauth-app\");\n\n// pkg/dist-src/auth.js\nvar import_deprecation = require(\"deprecation\");\nvar OAuthAppAuth = __toESM(require(\"@octokit/auth-oauth-app\"));\n\n// pkg/dist-src/get-app-authentication.js\nvar import_universal_github_app_jwt = require(\"universal-github-app-jwt\");\nfunction getAppAuthentication(_x) {\n  return _getAppAuthentication.apply(this, arguments);\n} // pkg/dist-src/cache.js\nfunction _getAppAuthentication() {\n  _getAppAuthentication = _asyncToGenerator(function* ({\n    appId,\n    privateKey,\n    timeDifference\n  }) {\n    try {\n      const appAuthentication = yield (0, import_universal_github_app_jwt.githubAppJwt)({\n        id: +appId,\n        privateKey,\n        now: timeDifference && Math.floor(Date.now() / 1e3) + timeDifference\n      });\n      return {\n        type: \"app\",\n        token: appAuthentication.token,\n        appId: appAuthentication.appId,\n        expiresAt: new Date(appAuthentication.expiration * 1e3).toISOString()\n      };\n    } catch (error) {\n      if (privateKey === \"-----BEGIN RSA PRIVATE KEY-----\") {\n        throw new Error(\"The 'privateKey` option contains only the first line '-----BEGIN RSA PRIVATE KEY-----'. If you are setting it using a `.env` file, make sure it is set on a single line with newlines replaced by '\\n'\");\n      } else {\n        throw error;\n      }\n    }\n  });\n  return _getAppAuthentication.apply(this, arguments);\n}\nvar import_lru_cache = require(\"lru-cache\");\nfunction getCache() {\n  return new import_lru_cache.LRUCache({\n    // cache max. 15000 tokens, that will use less than 10mb memory\n    max: 15e3,\n    // Cache for 1 minute less than GitHub expiry\n    ttl: 1e3 * 60 * 59\n  });\n}\nfunction get(_x2, _x3) {\n  return _get.apply(this, arguments);\n}\nfunction _get() {\n  _get = _asyncToGenerator(function* (cache, options) {\n    const cacheKey = optionsToCacheKey(options);\n    const result = yield cache.get(cacheKey);\n    if (!result) {\n      return;\n    }\n    const [token, createdAt, expiresAt, repositorySelection, permissionsString, singleFileName] = result.split(\"|\");\n    const permissions = options.permissions || permissionsString.split(/,/).reduce((permissions2, string) => {\n      if (/!$/.test(string)) {\n        permissions2[string.slice(0, -1)] = \"write\";\n      } else {\n        permissions2[string] = \"read\";\n      }\n      return permissions2;\n    }, {});\n    return {\n      token,\n      createdAt,\n      expiresAt,\n      permissions,\n      repositoryIds: options.repositoryIds,\n      repositoryNames: options.repositoryNames,\n      singleFileName,\n      repositorySelection\n    };\n  });\n  return _get.apply(this, arguments);\n}\nfunction set(_x4, _x5, _x6) {\n  return _set.apply(this, arguments);\n}\nfunction _set() {\n  _set = _asyncToGenerator(function* (cache, options, data) {\n    const key = optionsToCacheKey(options);\n    const permissionsString = options.permissions ? \"\" : Object.keys(data.permissions).map(name => `${name}${data.permissions[name] === \"write\" ? \"!\" : \"\"}`).join(\",\");\n    const value = [data.token, data.createdAt, data.expiresAt, data.repositorySelection, permissionsString, data.singleFileName].join(\"|\");\n    yield cache.set(key, value);\n  });\n  return _set.apply(this, arguments);\n}\nfunction optionsToCacheKey({\n  installationId,\n  permissions = {},\n  repositoryIds = [],\n  repositoryNames = []\n}) {\n  const permissionsString = Object.keys(permissions).sort().map(name => permissions[name] === \"read\" ? name : `${name}!`).join(\",\");\n  const repositoryIdsString = repositoryIds.sort().join(\",\");\n  const repositoryNamesString = repositoryNames.join(\",\");\n  return [installationId, repositoryIdsString, repositoryNamesString, permissionsString].filter(Boolean).join(\"|\");\n}\n\n// pkg/dist-src/to-token-authentication.js\nfunction toTokenAuthentication({\n  installationId,\n  token,\n  createdAt,\n  expiresAt,\n  repositorySelection,\n  permissions,\n  repositoryIds,\n  repositoryNames,\n  singleFileName\n}) {\n  return Object.assign({\n    type: \"token\",\n    tokenType: \"installation\",\n    token,\n    installationId,\n    permissions,\n    createdAt,\n    expiresAt,\n    repositorySelection\n  }, repositoryIds ? {\n    repositoryIds\n  } : null, repositoryNames ? {\n    repositoryNames\n  } : null, singleFileName ? {\n    singleFileName\n  } : null);\n}\n\n// pkg/dist-src/get-installation-authentication.js\nfunction getInstallationAuthentication(_x7, _x8, _x9) {\n  return _getInstallationAuthentication.apply(this, arguments);\n} // pkg/dist-src/auth.js\nfunction _getInstallationAuthentication() {\n  _getInstallationAuthentication = _asyncToGenerator(function* (state, options, customRequest) {\n    const installationId = Number(options.installationId || state.installationId);\n    if (!installationId) {\n      throw new Error(\"[@octokit/auth-app] installationId option is required for installation authentication.\");\n    }\n    if (options.factory) {\n      const {\n        type,\n        factory,\n        oauthApp,\n        ...factoryAuthOptions\n      } = {\n        ...state,\n        ...options\n      };\n      return factory(factoryAuthOptions);\n    }\n    const optionsWithInstallationTokenFromState = Object.assign({\n      installationId\n    }, options);\n    if (!options.refresh) {\n      const result = yield get(state.cache, optionsWithInstallationTokenFromState);\n      if (result) {\n        const {\n          token: token2,\n          createdAt: createdAt2,\n          expiresAt: expiresAt2,\n          permissions: permissions2,\n          repositoryIds: repositoryIds2,\n          repositoryNames: repositoryNames2,\n          singleFileName: singleFileName2,\n          repositorySelection: repositorySelection2\n        } = result;\n        return toTokenAuthentication({\n          installationId,\n          token: token2,\n          createdAt: createdAt2,\n          expiresAt: expiresAt2,\n          permissions: permissions2,\n          repositorySelection: repositorySelection2,\n          repositoryIds: repositoryIds2,\n          repositoryNames: repositoryNames2,\n          singleFileName: singleFileName2\n        });\n      }\n    }\n    const appAuthentication = yield getAppAuthentication(state);\n    const request = customRequest || state.request;\n    const {\n      data: {\n        token,\n        expires_at: expiresAt,\n        repositories,\n        permissions: permissionsOptional,\n        repository_selection: repositorySelectionOptional,\n        single_file: singleFileName\n      }\n    } = yield request(\"POST /app/installations/{installation_id}/access_tokens\", {\n      installation_id: installationId,\n      repository_ids: options.repositoryIds,\n      repositories: options.repositoryNames,\n      permissions: options.permissions,\n      mediaType: {\n        previews: [\"machine-man\"]\n      },\n      headers: {\n        authorization: `bearer ${appAuthentication.token}`\n      }\n    });\n    const permissions = permissionsOptional || {};\n    const repositorySelection = repositorySelectionOptional || \"all\";\n    const repositoryIds = repositories ? repositories.map(r => r.id) : void 0;\n    const repositoryNames = repositories ? repositories.map(repo => repo.name) : void 0;\n    const createdAt = /* @__PURE__ */new Date().toISOString();\n    yield set(state.cache, optionsWithInstallationTokenFromState, {\n      token,\n      createdAt,\n      expiresAt,\n      repositorySelection,\n      permissions,\n      repositoryIds,\n      repositoryNames,\n      singleFileName\n    });\n    return toTokenAuthentication({\n      installationId,\n      token,\n      createdAt,\n      expiresAt,\n      repositorySelection,\n      permissions,\n      repositoryIds,\n      repositoryNames,\n      singleFileName\n    });\n  });\n  return _getInstallationAuthentication.apply(this, arguments);\n}\nfunction auth(_x10, _x11) {\n  return _auth.apply(this, arguments);\n} // pkg/dist-src/hook.js\nfunction _auth() {\n  _auth = _asyncToGenerator(function* (state, authOptions) {\n    switch (authOptions.type) {\n      case \"app\":\n        return getAppAuthentication(state);\n      case \"oauth\":\n        state.log.warn(\n        // @ts-expect-error `log.warn()` expects string\n        new import_deprecation.Deprecation(`[@octokit/auth-app] {type: \"oauth\"} is deprecated. Use {type: \"oauth-app\"} instead`));\n      case \"oauth-app\":\n        return state.oauthApp({\n          type: \"oauth-app\"\n        });\n      case \"installation\":\n        authOptions;\n        return getInstallationAuthentication(state, {\n          ...authOptions,\n          type: \"installation\"\n        });\n      case \"oauth-user\":\n        return state.oauthApp(authOptions);\n      default:\n        throw new Error(`Invalid auth type: ${authOptions.type}`);\n    }\n  });\n  return _auth.apply(this, arguments);\n}\nvar import_auth_oauth_user = require(\"@octokit/auth-oauth-user\");\nvar import_request_error = require(\"@octokit/request-error\");\n\n// pkg/dist-src/requires-app-auth.js\nvar PATHS = [\"/app\", \"/app/hook/config\", \"/app/hook/deliveries\", \"/app/hook/deliveries/{delivery_id}\", \"/app/hook/deliveries/{delivery_id}/attempts\", \"/app/installations\", \"/app/installations/{installation_id}\", \"/app/installations/{installation_id}/access_tokens\", \"/app/installations/{installation_id}/suspended\", \"/marketplace_listing/accounts/{account_id}\", \"/marketplace_listing/plan\", \"/marketplace_listing/plans\", \"/marketplace_listing/plans/{plan_id}/accounts\", \"/marketplace_listing/stubbed/accounts/{account_id}\", \"/marketplace_listing/stubbed/plan\", \"/marketplace_listing/stubbed/plans\", \"/marketplace_listing/stubbed/plans/{plan_id}/accounts\", \"/orgs/{org}/installation\", \"/repos/{owner}/{repo}/installation\", \"/users/{username}/installation\"];\nfunction routeMatcher(paths) {\n  const regexes = paths.map(p => p.split(\"/\").map(c => c.startsWith(\"{\") ? \"(?:.+?)\" : c).join(\"/\"));\n  const regex = `^(?:${regexes.map(r => `(?:${r})`).join(\"|\")})$`;\n  return new RegExp(regex, \"i\");\n}\nvar REGEX = routeMatcher(PATHS);\nfunction requiresAppAuth(url) {\n  return !!url && REGEX.test(url.split(\"?\")[0]);\n}\n\n// pkg/dist-src/hook.js\nvar FIVE_SECONDS_IN_MS = 5 * 1e3;\nfunction isNotTimeSkewError(error) {\n  return !(error.message.match(/'Expiration time' claim \\('exp'\\) must be a numeric value representing the future time at which the assertion expires/) || error.message.match(/'Issued at' claim \\('iat'\\) must be an Integer representing the time that the assertion was issued/));\n}\nfunction hook(_x12, _x13, _x14, _x15) {\n  return _hook.apply(this, arguments);\n}\nfunction _hook() {\n  _hook = _asyncToGenerator(function* (state, request, route, parameters) {\n    const endpoint = request.endpoint.merge(route, parameters);\n    const url = endpoint.url;\n    if (/\\/login\\/oauth\\/access_token$/.test(url)) {\n      return request(endpoint);\n    }\n    if (requiresAppAuth(url.replace(request.endpoint.DEFAULTS.baseUrl, \"\"))) {\n      const {\n        token: token2\n      } = yield getAppAuthentication(state);\n      endpoint.headers.authorization = `bearer ${token2}`;\n      let response;\n      try {\n        response = yield request(endpoint);\n      } catch (error) {\n        if (isNotTimeSkewError(error)) {\n          throw error;\n        }\n        if (typeof error.response.headers.date === \"undefined\") {\n          throw error;\n        }\n        const diff = Math.floor((Date.parse(error.response.headers.date) - Date.parse( /* @__PURE__ */new Date().toString())) / 1e3);\n        state.log.warn(error.message);\n        state.log.warn(`[@octokit/auth-app] GitHub API time and system time are different by ${diff} seconds. Retrying request with the difference accounted for.`);\n        const {\n          token: token3\n        } = yield getAppAuthentication({\n          ...state,\n          timeDifference: diff\n        });\n        endpoint.headers.authorization = `bearer ${token3}`;\n        return request(endpoint);\n      }\n      return response;\n    }\n    if ((0, import_auth_oauth_user.requiresBasicAuth)(url)) {\n      const authentication = yield state.oauthApp({\n        type: \"oauth-app\"\n      });\n      endpoint.headers.authorization = authentication.headers.authorization;\n      return request(endpoint);\n    }\n    const {\n      token,\n      createdAt\n    } = yield getInstallationAuthentication(state,\n    // @ts-expect-error TBD\n    {}, request);\n    endpoint.headers.authorization = `token ${token}`;\n    return sendRequestWithRetries(state, request, endpoint, createdAt);\n  });\n  return _hook.apply(this, arguments);\n}\nfunction sendRequestWithRetries(_x16, _x17, _x18, _x19) {\n  return _sendRequestWithRetries.apply(this, arguments);\n} // pkg/dist-src/version.js\nfunction _sendRequestWithRetries() {\n  _sendRequestWithRetries = _asyncToGenerator(function* (state, request, options, createdAt, retries = 0) {\n    const timeSinceTokenCreationInMs = + /* @__PURE__ */new Date() - +new Date(createdAt);\n    try {\n      return yield request(options);\n    } catch (error) {\n      if (error.status !== 401) {\n        throw error;\n      }\n      if (timeSinceTokenCreationInMs >= FIVE_SECONDS_IN_MS) {\n        if (retries > 0) {\n          error.message = `After ${retries} retries within ${timeSinceTokenCreationInMs / 1e3}s of creating the installation access token, the response remains 401. At this point, the cause may be an authentication problem or a system outage. Please check https://www.githubstatus.com for status information`;\n        }\n        throw error;\n      }\n      ++retries;\n      const awaitTime = retries * 1e3;\n      state.log.warn(`[@octokit/auth-app] Retrying after 401 response to account for token replication delay (retry: ${retries}, wait: ${awaitTime / 1e3}s)`);\n      yield new Promise(resolve => setTimeout(resolve, awaitTime));\n      return sendRequestWithRetries(state, request, options, createdAt, retries);\n    }\n  });\n  return _sendRequestWithRetries.apply(this, arguments);\n}\nvar VERSION = \"6.0.1\";\n\n// pkg/dist-src/index.js\nvar import_auth_oauth_user2 = require(\"@octokit/auth-oauth-user\");\nfunction createAppAuth(options) {\n  if (!options.appId) {\n    throw new Error(\"[@octokit/auth-app] appId option is required\");\n  }\n  if (!Number.isFinite(+options.appId)) {\n    throw new Error(\"[@octokit/auth-app] appId option must be a number or numeric string\");\n  }\n  if (!options.privateKey) {\n    throw new Error(\"[@octokit/auth-app] privateKey option is required\");\n  }\n  if (\"installationId\" in options && !options.installationId) {\n    throw new Error(\"[@octokit/auth-app] installationId is set to a falsy value\");\n  }\n  const log = Object.assign({\n    warn: console.warn.bind(console)\n  }, options.log);\n  const request = options.request || import_request.request.defaults({\n    headers: {\n      \"user-agent\": `octokit-auth-app.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`\n    }\n  });\n  const state = Object.assign({\n    request,\n    cache: getCache()\n  }, options, options.installationId ? {\n    installationId: Number(options.installationId)\n  } : {}, {\n    log,\n    oauthApp: (0, import_auth_oauth_app.createOAuthAppAuth)({\n      clientType: \"github-app\",\n      clientId: options.clientId || \"\",\n      clientSecret: options.clientSecret || \"\",\n      request\n    })\n  });\n  return Object.assign(auth.bind(null, state), {\n    hook: hook.bind(null, state)\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  createAppAuth,\n  createOAuthUserAuth\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}