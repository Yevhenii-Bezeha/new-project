{"ast":null,"code":"import _asyncToGenerator from \"/Users/ybezeha/WebstormProjects/new-project/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// pkg/dist-src/index.js\nimport { getUserAgent } from \"universal-user-agent\";\nimport { request as octokitRequest } from \"@octokit/request\";\n\n// pkg/dist-src/version.js\nvar VERSION = \"4.0.0\";\n\n// pkg/dist-src/get-authentication.js\nimport { createOAuthDeviceAuth } from \"@octokit/auth-oauth-device\";\nimport { exchangeWebFlowCode } from \"@octokit/oauth-methods\";\nfunction getAuthentication(_x) {\n  return _getAuthentication.apply(this, arguments);\n} // pkg/dist-src/auth.js\nfunction _getAuthentication() {\n  _getAuthentication = _asyncToGenerator(function* (state) {\n    if (\"code\" in state.strategyOptions) {\n      const {\n        authentication\n      } = yield exchangeWebFlowCode({\n        clientId: state.clientId,\n        clientSecret: state.clientSecret,\n        clientType: state.clientType,\n        onTokenCreated: state.onTokenCreated,\n        ...state.strategyOptions,\n        request: state.request\n      });\n      return {\n        type: \"token\",\n        tokenType: \"oauth\",\n        ...authentication\n      };\n    }\n    if (\"onVerification\" in state.strategyOptions) {\n      const deviceAuth = createOAuthDeviceAuth({\n        clientType: state.clientType,\n        clientId: state.clientId,\n        onTokenCreated: state.onTokenCreated,\n        ...state.strategyOptions,\n        request: state.request\n      });\n      const authentication = yield deviceAuth({\n        type: \"oauth\"\n      });\n      return {\n        clientSecret: state.clientSecret,\n        ...authentication\n      };\n    }\n    if (\"token\" in state.strategyOptions) {\n      return {\n        type: \"token\",\n        tokenType: \"oauth\",\n        clientId: state.clientId,\n        clientSecret: state.clientSecret,\n        clientType: state.clientType,\n        onTokenCreated: state.onTokenCreated,\n        ...state.strategyOptions\n      };\n    }\n    throw new Error(\"[@octokit/auth-oauth-user] Invalid strategy options\");\n  });\n  return _getAuthentication.apply(this, arguments);\n}\nimport { checkToken, deleteAuthorization, deleteToken, refreshToken, resetToken } from \"@octokit/oauth-methods\";\nfunction auth(_x2) {\n  return _auth.apply(this, arguments);\n} // pkg/dist-src/hook.js\nfunction _auth() {\n  _auth = _asyncToGenerator(function* (state, options = {}) {\n    if (!state.authentication) {\n      state.authentication = state.clientType === \"oauth-app\" ? yield getAuthentication(state) : yield getAuthentication(state);\n    }\n    if (state.authentication.invalid) {\n      throw new Error(\"[@octokit/auth-oauth-user] Token is invalid\");\n    }\n    const currentAuthentication = state.authentication;\n    if (\"expiresAt\" in currentAuthentication) {\n      if (options.type === \"refresh\" || new Date(currentAuthentication.expiresAt) < /* @__PURE__ */new Date()) {\n        const {\n          authentication\n        } = yield refreshToken({\n          clientType: \"github-app\",\n          clientId: state.clientId,\n          clientSecret: state.clientSecret,\n          refreshToken: currentAuthentication.refreshToken,\n          request: state.request\n        });\n        state.authentication = {\n          tokenType: \"oauth\",\n          type: \"token\",\n          ...authentication\n        };\n      }\n    }\n    if (options.type === \"refresh\") {\n      if (state.clientType === \"oauth-app\") {\n        throw new Error(\"[@octokit/auth-oauth-user] OAuth Apps do not support expiring tokens\");\n      }\n      if (!currentAuthentication.hasOwnProperty(\"expiresAt\")) {\n        throw new Error(\"[@octokit/auth-oauth-user] Refresh token missing\");\n      }\n      yield state.onTokenCreated?.(state.authentication, {\n        type: options.type\n      });\n    }\n    if (options.type === \"check\" || options.type === \"reset\") {\n      const method = options.type === \"check\" ? checkToken : resetToken;\n      try {\n        const {\n          authentication\n        } = yield method({\n          // @ts-expect-error making TS happy would require unnecessary code so no\n          clientType: state.clientType,\n          clientId: state.clientId,\n          clientSecret: state.clientSecret,\n          token: state.authentication.token,\n          request: state.request\n        });\n        state.authentication = {\n          tokenType: \"oauth\",\n          type: \"token\",\n          // @ts-expect-error TBD\n          ...authentication\n        };\n        if (options.type === \"reset\") {\n          yield state.onTokenCreated?.(state.authentication, {\n            type: options.type\n          });\n        }\n        return state.authentication;\n      } catch (error) {\n        if (error.status === 404) {\n          error.message = \"[@octokit/auth-oauth-user] Token is invalid\";\n          state.authentication.invalid = true;\n        }\n        throw error;\n      }\n    }\n    if (options.type === \"delete\" || options.type === \"deleteAuthorization\") {\n      const method = options.type === \"delete\" ? deleteToken : deleteAuthorization;\n      try {\n        yield method({\n          // @ts-expect-error making TS happy would require unnecessary code so no\n          clientType: state.clientType,\n          clientId: state.clientId,\n          clientSecret: state.clientSecret,\n          token: state.authentication.token,\n          request: state.request\n        });\n      } catch (error) {\n        if (error.status !== 404) throw error;\n      }\n      state.authentication.invalid = true;\n      return state.authentication;\n    }\n    return state.authentication;\n  });\n  return _auth.apply(this, arguments);\n}\nimport btoa from \"btoa-lite\";\n\n// pkg/dist-src/requires-basic-auth.js\nvar ROUTES_REQUIRING_BASIC_AUTH = /\\/applications\\/[^/]+\\/(token|grant)s?/;\nfunction requiresBasicAuth(url) {\n  return url && ROUTES_REQUIRING_BASIC_AUTH.test(url);\n}\n\n// pkg/dist-src/hook.js\nfunction hook(_x3, _x4, _x5) {\n  return _hook.apply(this, arguments);\n} // pkg/dist-src/index.js\nfunction _hook() {\n  _hook = _asyncToGenerator(function* (state, request, route, parameters = {}) {\n    const endpoint = request.endpoint.merge(route, parameters);\n    if (/\\/login\\/(oauth\\/access_token|device\\/code)$/.test(endpoint.url)) {\n      return request(endpoint);\n    }\n    if (requiresBasicAuth(endpoint.url)) {\n      const credentials = btoa(`${state.clientId}:${state.clientSecret}`);\n      endpoint.headers.authorization = `basic ${credentials}`;\n      return request(endpoint);\n    }\n    const {\n      token\n    } = state.clientType === \"oauth-app\" ? yield auth({\n      ...state,\n      request\n    }) : yield auth({\n      ...state,\n      request\n    });\n    endpoint.headers.authorization = \"token \" + token;\n    return request(endpoint);\n  });\n  return _hook.apply(this, arguments);\n}\nfunction createOAuthUserAuth({\n  clientId,\n  clientSecret,\n  clientType = \"oauth-app\",\n  request = octokitRequest.defaults({\n    headers: {\n      \"user-agent\": `octokit-auth-oauth-app.js/${VERSION} ${getUserAgent()}`\n    }\n  }),\n  onTokenCreated,\n  ...strategyOptions\n}) {\n  const state = Object.assign({\n    clientType,\n    clientId,\n    clientSecret,\n    onTokenCreated,\n    strategyOptions,\n    request\n  });\n  return Object.assign(auth.bind(null, state), {\n    // @ts-expect-error not worth the extra code needed to appease TS\n    hook: hook.bind(null, state)\n  });\n}\ncreateOAuthUserAuth.VERSION = VERSION;\nexport { createOAuthUserAuth, requiresBasicAuth };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}